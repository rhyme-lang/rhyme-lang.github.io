!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.rhyme=t():e.rhyme=t()}(this,(()=>(()=>{var __webpack_modules__={994:()=>{},840:()=>{},35:(__unused_webpack_module,exports,__webpack_require__)=>{const{quoteVar,debug,trace,print,inspect,error,warn}=__webpack_require__(798);exports.generate=ir=>{let assignmentStms=ir.assignmentStms,generatorStms=ir.generatorStms,tmpVarWriteRank=ir.tmpVarWriteRank,res=ir.res,explain={};explain.src=ir.query;let code=[],indent=0;function emit(e){0==e.indexOf("}")&&indent--,code.push("".padEnd(4*indent," ")+e),e.indexOf("{")>=0&&indent++,e.indexOf("}")>0&&indent--}if(emit("inp => {"),emit("let tmp = {}"),debug){print("---- begin code ----");for(let e of assignmentStms)e.txt.indexOf("??=")<0&&print(e.txt+"  // "+e.writeSym+" #"+e.writeRank+" <- "+e.deps);print("return "+res.txt),print("---- end code ----")}explain.ir={},explain.ir.assignments=[...assignmentStms],explain.ir.generators=[...generatorStms];let generatorStmsCopy=[...generatorStms],tmpInsideLoop={},tmpAfterLoop={},tmpAfterTmp={},loopAfterLoop={},loopInsideLoop={};for(let e of assignmentStms){let t=e=>e.startsWith("*"),r=e=>e.startsWith("tmp");tmpInsideLoop[e.writeSym]??={},tmpAfterTmp[e.writeSym]??={};for(let n of e.deps)t(n)&&(tmpInsideLoop[e.writeSym][n]=!0),r(n)&&(tmpAfterTmp[e.writeSym][n]=!0)}for(let e in tmpAfterTmp){tmpAfterLoop[e]??={};for(let t in tmpAfterTmp[e])for(let r in tmpInsideLoop[t])tmpAfterLoop[e][r]=!0;for(let t in tmpInsideLoop[e])delete tmpAfterLoop[e][t]}for(let e in tmpInsideLoop)for(let t in tmpInsideLoop[e]){loopInsideLoop[t]??={};for(let r in tmpInsideLoop[e])loopInsideLoop[t][r]=!0,loopInsideLoop[r]??={},loopInsideLoop[r][t]=!0}for(let e in tmpAfterLoop)for(let t in tmpInsideLoop[e]){loopAfterLoop[t]??={};for(let r in tmpAfterLoop[e])loopInsideLoop[t]&&loopInsideLoop[t][r]||(loopAfterLoop[t][r]=!0)}explain.dependencies={tmpInsideLoop,tmpAfterTmp,tmpAfterLoop,loopAfterLoop,loopInsideLoop};let extraLoopDeps=loopAfterLoop;debug&&(inspect({tmpInsideLoop,tmpAfterTmp,tmpAfterLoop,loopAfterLoop,loopInsideLoop}),print("---- end dependency data ----"));let availableSyms={},emittedLoopSyms={},emittedSymsRank={};function isAvailable(e){return"inp"==e||(e.startsWith("*")?availableSyms[e]:!!e.startsWith("tmp")&&emittedSymsRank[e]==tmpVarWriteRank[e])}function depsAvailable(e){return e.deps.every(isAvailable)}function extraDepsAvailable(e){return Object.keys(e).every((e=>emittedLoopSyms[e]))}function loopsFinished(e){return extraDepsAvailable(tmpAfterLoop[e.writeSym])}function filterAvailable(e){return e.filter((e=>depsAvailable(e)&&loopsFinished(e)))}function filterNotAvailable(e){return e.filter((e=>!depsAvailable(e)||!loopsFinished(e)))}function emitAssignments(){let e=filterAvailable(assignmentStms);assignmentStms=filterNotAvailable(assignmentStms);for(let t of e)emit(t.txt),emittedSymsRank[t.writeSym]=t.writeRank+1}function emitGenerators(e){let t={};for(let e of generatorStms)t[e.sym]||(t[e.sym]=[]),t[e.sym].push(e);function r(e){return t[e].every(depsAvailable)&&extraDepsAvailable(extraLoopDeps[e])}generatorStms=[];let n={};for(let e in t)r(e)?n[e]=!0:generatorStms.push(...t[e]);for(let e in n){if(!r(e))continue;let[n,...o]=t[e];generatorStms=generatorStms.filter((t=>t.sym!=e)),emit("for (let "+quoteVar(n.sym)+" in "+n.rhs+") {");for(let e of o)emit("if ("+e.rhs+"["+quoteVar(e.sym)+"] === undefined) continue");availableSyms[e]=!0,emitConvergence(),delete availableSyms[e],emit("}"),emittedLoopSyms[e]=!0,emitAssignments()}}function emitConvergence(){let e;do{do{e=code.length,emitAssignments()}while(e<code.length);emitGenerators()}while(e<code.length)}if(emitConvergence(),assignmentStms.length>0){print("WARN - re-emitting generators because assignments remaining"),emit("// --- repeated generators ---");let e={};for(let t of generatorStmsCopy)e[t.sym]||(e[t.sym]=[]),e[t.sym].push(t);for(let t of assignmentStms){let r={};t.deps.filter((e=>e.startsWith("*"))).forEach((e=>r[e]=!0));for(let t in r)emit("for (let "+quoteVar(t)+" in "+e[t][0].rhs+") {");emit(t.txt);for(let e in r)emit("}")}assignmentStms=[]}if(assignmentStms.length){warn("ERROR - couldn't emit the following assignments (most likely due to circular dependencies:");for(let e of assignmentStms)warn(e.txt+" ---- "+e.deps)}emit("return "+res.txt),emit("}"),trace&&code.forEach((e=>print(e)));let codeString=code.join("\n"),queryFunc=eval(codeString);return queryFunc.explain=explain,queryFunc.explain.code=code,queryFunc.explain.codeString=codeString,queryFunc}},543:(e,t,r)=>{const{quoteVar:n,debug:o,trace:i,print:s,inspect:p,error:a,warn:l}=r(798),{parse:u}=r(612);t.createIR=e=>{let t=e=>e.startsWith("*"),r=(e,...t)=>({txt:e,deps:t}),o=e=>t(e)?r(n(e),e):r("'"+e+"'"),i=e=>1==e.deps.length&&e.txt==n(e.deps[0]),p=(e,t)=>r(e.txt+"["+t.txt+"]",...e.deps,...t.deps),l=(e,...t)=>r(e.txt+"("+t.map((e=>e.txt)).join(",")+")",...e.deps,...t.map((e=>e.deps)).flat()),f=(e,t,n)=>r("("+t.txt+e+n.txt+")",...t.deps,...n.deps),m=(e,t)=>r(e+"("+t.txt+")",...t.deps),y=[],d=[],c={},g=[],h=0,x={},k={};function v(e,t,n){let o=r(e.txt+" "+t+" "+n.txt,...e.deps,...n.deps);o.lhs=e,o.op=t,o.rhs=n,o.writeSym=e.root,o.deps=o.deps.filter((e=>e!=o.writeSym)),x[o.writeSym]??=1,o.writeRank=x[o.writeSym],x[o.writeSym]+=1,d.push(o)}function b(e){if("object"==typeof e||"function"==typeof e){if(e.xxpath){if("ident"==e.xxpath)return o(e.xxparam);if("raw"==e.xxpath)return r(e.xxparam);if("get"==e.xxpath){let[n,s]=e.xxparam;void 0===s&&(s=n,n={xxpath:"raw",xxparam:"inp"});let a=JSON.stringify(n),l=k[a];if(!l){if(l=b(n),"apply"==n.xxpath){let e=function(e){let n=p(r("tmp"),r(""+h++)),i=n.txt;n.root=i,n.deps=[i];let s=e.filter(t);for(let e of s)v(n,"??=",r("{}")),n=p(n,o(e)),n.root=i;return n}(l.deps);v(e,"=",l),l=e}k[a]=l}return function(e,t){if(i(t)){let n=t.deps[0],o=r("for "+n+" <- "+e.txt,...e.deps);o.sym=n,o.rhs=e.txt,y.every((e=>e.txt!=o.txt))&&y.push(o),c[n]=!0}return p(e,t)}(l,b(s))}if("apply"==e.xxpath){let[t,...r]=e.xxparam;return l(b(t),...r.map(b))}if("plus"==e.xxpath){let[t,r]=e.xxparam;return f("+",b(t),b(r))}if("minus"==e.xxpath){let[t,r]=e.xxparam;return f("-",b(t),b(r))}if("times"==e.xxpath){let[t,r]=e.xxparam;return f("*",b(t),b(r))}if("fdiv"==e.xxpath){let[t,r]=e.xxparam;return f("/",b(t),b(r))}if("div"==e.xxpath){let[t,r]=e.xxparam;return m("Math.trunc",f("/",b(t),b(r)))}if("mod"==e.xxpath){let[t,r]=e.xxparam;return m("Math.trunc",f("%",b(t),b(r)))}if("and"==e.xxpath){let[t,r]=e.xxparam;return f("&&",b(t),b(r))}return a("ERROR - unknown path key '"+e.xxpath+"'"),r("undefined")}if(e.xxkey)return $(e);if(e instanceof Array)return s("WARN - Array in path expr not thoroughly tested yet!"),$({xxkey:"array",xxparam:e});{let n={},i={},s={};for(let t of Object.keys(e)){let r=e[t];"keyval"==e[t].xxkey||"merge"==e[t].xxkey?(r=e[t].xxparam[1],t=e[t].xxparam[0]):"flatten"==e[t].xxkey&&(r=e[t].xxparam[1],t=api.plus(api.plus(t,"-"),e[t].xxparam[0]));let o=S(t),p=g;g=[...g,o];let a=S(r);g=p,n[t]={key:o,rhs:a};for(let e of o.deps)i[e]=!0;for(let e of a.deps)s[e]=!0}let a=g,l={};for(let e of g)for(let t of e.deps)l[t]=!0;let u={};for(let e in i)e in l||(u[e]=!0);let f=[];for(let e in s)t(e)&&!(e in u)&&f.push(e);let m=f.map(o).filter((e=>!g.some((t=>e.txt==t.txt)))),y=[];for(let e in s)t(e)&&y.push(e);for(let e in i)t(e)&&y.push(e);g=[...g,...m];let d=_(y);v(d,"??=",r("{} //"));for(let t of Object.keys(e)){"keyval"==e[t].xxkey||"merge"==e[t].xxkey?t=e[t].xxparam[0]:"flatten"==e[t].xxkey&&(t=api.plus(api.plus(t,"-"),e[t].xxparam[0]));let{key:r,rhs:o}=n[t],i=p(d,r);i.root=d.root,v(i,"=",o)}return g=a,d}}return function(e){return"number"!=typeof e&&Number.isNaN(Number(e))?b("$display"==e?{xxpath:"ident",xxparam:"$display"}:u(e)):r(e)}("number"==typeof e?e:String(e))}function S(e){return b(e)}function $(e){return E(null,e)}function w(e){if(!e)return g;let t=[];for(let r of g)r.deps.length&&!r.deps.some((t=>e.indexOf(t)>=0))||t.push(r);return t}function _(e){let t=p(r("tmp"),r(""+h++)),n=t.txt;t.root=n,t.deps=[n];for(let o of w(e))v(t,"??=",r("{}")),t=p(t,o),t.root=n;return t}function q(e,t){return e&&function(e){return g.length==w(e).length}(t)?e:_(t)}function j(e,t){return e&&e!=t?(v(e,"=",t),e):t}function E(e,t){if("sum"==t.xxkey){let n=S(t.xxparam),o=q(e,n.deps);return v(o,"??=",r("0")),v(o,"+=",n),j(e,o)}if("product"==t.xxkey){let n=S(t.xxparam),o=q(e,n.deps);return v(o,"??=",r("1")),v(o,"*=",n),j(e,o)}if("count"==t.xxkey){let n=S(t.xxparam),o=q(e,n.deps);return v(o,"??=",r("0")),v(o,"+=",r("1",...n.deps)),j(e,o)}if("min"==t.xxkey){let n=S(t.xxparam),o=q(e,n.deps);return v(o,"??=",r("Infinity")),v(o,"=",r("Math.min("+o.txt+","+n.txt+")",...n.deps)),j(e,o)}if("max"==t.xxkey){let n=S(t.xxparam),o=q(e,n.deps);return v(o,"??=",r("-Infinity")),v(o,"=",r("Math.max("+o.txt+","+n.txt+")",...n.deps)),j(e,o)}if("first"==t.xxkey){let n=S(t.xxparam),o=q(e,n.deps);return v(o,"??=",r(n.txt,...n.deps)),j(e,o)}if("last"==t.xxkey){let n=S(t.xxparam),o=q(e,n.deps);return v(o,"=",r(n.txt+" ?? "+o.txt,...n.deps)),j(e,o)}if("join"==t.xxkey){let n=S(t.xxparam),o=q(e,n.deps);return v(o,"??=",r("''")),v(o,"+=",n),j(e,o)}if("array"==t.xxkey&&t.xxparam.length>1){let n=t.xxparam.map(S),o=q(e,n.flatMap((e=>e.deps))),i=[];for(let e of n){let t=_(e.deps);v(t,"??=",r("[]")),v(t,".push",r("("+e.txt+")",...e.deps)),i.push(t)}return v(o,"=",r("["+i.map((e=>e.txt)).join(",")+"].flat()",...i.flatMap((e=>e.deps)))),j(e,o)}if("array"==t.xxkey){let n=t.xxparam.map(S),o=q(e,n.flatMap((e=>e.deps)));v(o,"??=",r("[]"));for(let e of n)v(o,".push",r("("+e.txt+")",...e.deps));return j(e,o)}if(t.xxkey)return a("ERROR: unknown reducer key '"+t.xxkey+"'"),r("undefined");if(t instanceof Array)return E(e,{xxkey:"array",xxparam:t});if(t instanceof Array){t.length>1&&a("ERROR: currently not dealing correctly with multi-element arrays");let n=q(e,null);v(n,"??=",r("[]"));let o=0;for(let e in t)t[e];for(let e in t){let r=t[e];o=api.plus(o,api.count(r));let i=S(api.minus(o,1)),s=g;g=[...g,i];let a=p(n,i);a.root=n.root,E(a,r),g=s}return j(e,n)}if("object"!=typeof t||t.xxpath){let r=S(t),n=q(e,r.deps);return v(n,"=",r),j(e,n)}{let n=q(e,null);v(n,"??=",r("{}"));let o=Object.keys(t);for(let e of o){let r=t[e];"keyval"==t[e].xxkey||"merge"==t[e].xxkey?(r=t[e].xxparam[1],e=t[e].xxparam[0]):"flatten"==t[e].xxkey&&(r=t[e].xxparam[1],e=api.plus(api.plus(e,"-"),t[e].xxparam[0]));let o=S(e),i=g;g=[...g,o];let s=p(n,o);s.root=n.root,E(s,r),g=i}return j(e,n)}}let P=E(null,e);return{assignmentStms:d,generatorStms:y,tmpVarWriteRank:x,res:P,query:e}}},824:(e,t)=>{t.desugar=e=>{let t={xxpath:"raw",xxparam:"inp"},r=!1,n={};function o(e,n){if("get"==e){let[e,...o]=n;return 0!=o.length&&void 0!==o[0]||(o=[e],e=t,r=!0),"ident"==e.xxpath&&(e={xxpath:"get",xxparam:[{xxpath:"raw",xxparam:"inp"},e]}),{xxpath:"get",xxparam:[e,...o]}}return{xxpath:e,xxparam:n}}function i(e,t){return{xxkey:e,xxparam:t}}let s={sum:!0,product:!0,count:!0,max:!0,min:!0,first:!0,last:!0,print:!0};function p(e,a){let u=[t,r];t=a[0],r=!1,e=l(e);let f=r;if(t=u[0],r=u[1],e instanceof Function)return e(...a);if(f)return e;if("ident"==e.xxpath)return function(e,t){return"get"==e?o("get",t):s[e]?i(e,t[0]):"group"==e&&t.length<2?{xxpath:"group",xxparam:t[0]}:"loadCSV"==e?{xxpath:"loadCSV",xxparam:t[0],xxextra:t[1]}:{xxpath:"apply",xxparam:[{xxpath:"ident",xxparam:e},...t]}}(e.xxparam,a);if("get"==e.xxpath&&1==e.xxparam.length)return{xxpath:"get",xxparam:[a[0],e.xxparam[0]]};if("group"==e.xxpath)return{_IGNORE_:{xxkey:"keyval",xxparam:[e.xxparam,a[0]]}};if("closure"==e.xxpath){console.assert(a.length>=1);let[t,...r]=a,[o,i,s]=e.xxparam,u=n;n={...o},n[i.xxparam]=a[0];let f=l(s);return n=u,r.length>0?p(f,r):f}return{xxpath:"apply",xxparam:[e,...a]}}function a(e,t){if("ident"==e.xxpath&&"let"==e.xxparam){console.assert(t.length>=3),console.assert("ident"==t[0].xxpath);let[e,r,o,...i]=t;r=l(r);let s=n;n={...n},n[e.xxparam]=r;let p=l(o);return n=s,i.length>0?a(p,i):p}if("ident"==e.xxpath&&"fn"==e.xxparam){console.assert(t.length>=2),console.assert("ident"==t[0].xxpath);let[e,r,...o]=t,i={xxpath:"closure",xxparam:[n,e,r]};return o.length>0?a(i,o):i}if("apply"==e.xxpath){let[r,...n]=e.xxparam;return a(r,[...n,...t])}return p(e,t.map(l))}function l(e){if(null==e)return e;if("ident"==e.xxpath)return e.xxparam in n?n[e.xxparam]:e;if("raw"==e.xxpath)return"_ARG_"==e.xxparam?(r=!0,t):e;if("hole"==e.xxpath)return e.xxparam;if("pipe"==e.xxpath){let[t,r,...n]=e.xxparam;return function(e,t){return console.assert(1==t.length),p(e,t.map(l))}(r,[t,...n])}if("apply"==e.xxpath){let[t,...r]=e.xxparam;return a(t,r)}return e.xxpath?o(e.xxpath,e.xxparam.map(l)):e.xxkey?i(e.xxkey,l(e.xxparam)):e}return l(e)}},462:(e,t)=>{t.display=(e,t)=>{const r=function(e,t,...r){const n=e.startsWith("svg:")?document.createElementNS("http://www.w3.org/2000/svg",e.slice(4)):document.createElement(e);for(let e in t)if(e.startsWith("on"))n.addEventListener(e.toLowerCase().substring(2),t[e]);else if("style"==e)for(let r in t[e])n[e][r]=t[e][r];else n.setAttribute&&n.setAttribute(e,t[e]),n[e]=t[e];for(let e of r)e instanceof Node||(e=document.createTextNode(e)),n.appendChild(e);return n};function n(...e){return r("span",{},...e)}let o=new function(){this.get=function(){return{...this}},this.set=function(e){for(let e in this)delete this[e];for(let t in e)this[t]=e[t]},this.begin=function(){this.save=this.get()},this.end=function(){console.assert(this.save,"too many m.end!",this),this.set(this.save)},this.enter=function(e){this.begin(),this.set(e)},this.exit=function(){this.end()}};o.local=function(e){let t=this.get();return(...r)=>{this.enter(t);let n=e(...r);return this.exit(),n}};let i=o.begin;function s(e,t){let r,n=20*t;if(0==t)return"...";if(e instanceof Array){let r=["["];for(let n=0;n<e.length;n++)r.length>1&&r.push(", "),r.push(s(e[n],t-1));r.push("]");let o=r.join("");return o.length>n&&(o=o.substring(0,n)+"..."),o}if(e&&"object"==typeof e){let n=[];e.constructor!=Object&&n.push(e.constructor.name," "),n.push("{");let o=n.length;for(let r of Object.keys(e))n.length>o&&n.push(", "),n.push(r,": ",s(e[r],t-1));n.push("}"),r=n.join("")}else r="function"==typeof e?"function":String(e);return r.length>n&&(r=r.substring(0,n)+"..."),r}function p(e,t){let o;if(e&&"object"==typeof e){o=r("div",{});let l=!1;function i(){l=!l,a()}function a(){let a=r("span",{onClick:i},l?"▽ ":"▷ ");if(a.style.display="inline-block",a.style.width="2ch",o.innerText="",o.appendChild(a),t&&o.appendChild(n(t,": ")),!l){let t=s(e,3);o.appendChild(n(t))}if(l){o.appendChild(n(e?.constructor.name));let t=[];for(let r of Object.keys(e))t.push(p(e[r],r));let i=r("div",{},...t);i.style.marginLeft="2ch",o.appendChild(i)}}a()}else"function"==typeof e?t?(o=r("div",{},t,": ","function"),o.style.marginLeft="2ch"):o=r("div",{},"function"):t?(o=r("div",{},t,": ",String(e)),o.style.marginLeft="2ch"):o=r("div",{},String(e));return o}function a(e){switch(e?.$display){case"table":return function(e,t,r,n,i,s){let p=0,l=0,u=0;if(e&&(p="number"==typeof e?e:e.length),t&&(l="number"==typeof t?t:t.length),s||(s=(e,t)=>{""!=e&&(o.domParent.style.border="thin solid black",o.domParent.style.background="#EEEEEE",o.domParent.style.padding="0px 5px 0px 5px",o.styled("inline",String(e)))}),i||(i=(e,t)=>{o.domParent.style.border="thin solid lightgray",o.domParent.style.padding="0px 5px 0px 5px",o.domParent.style["vertical-align"]="middle",a(e)}),!n){n=r;for(let e=0;e<p;e++)n=n.Total||n[0]||n[Object.keys(n)[0]]}function f(e,t){return function e(r,n,o,i){let s,p={},a=0;if(function(e){return e instanceof Object&&"children"in e}(r)&&(r=r.children,s=!0,a=1),i<t){let t=0;for(let n in r)p[n]=e(r[n],n,t++,i+1),a+=p[n].span}else a=1;return{span:a,key:n,index:o,sub:p,special:s}}(e,"root",0,0)}let m=f(n,l),y=f(r,p);function d(e,t,r,n){let o=[];!function e(t,i,s){if(o[s]=t,s<r){t.special&&i&&(n(t,i.props,o,s),i=i.children);for(let r in t.sub)e(t.sub[r],i?i[r]:null,s+1)}else n(t,i,o,s)}(e,t,0)}y.special&&(u+=1),o.begin("min-w-full max-w-xl overflow-auto"),o.begin(o.table()),o.domParent.className="table-fixed xxmin-w-full",o.domParent.style["border-collapse"]="collapse";let c=p+u+m.span;for(let e=0;e<c;e++)o.col().className="w-48";o.begin(o.thead()),o.domParent.className="border-b border-gray-200 divide-gray-200";for(let e=0;e<l;e++)o.begin(o.tr()),0==e&&l&&p+u&&(o.begin(o.th()),o.domParent.rowSpan=l,o.domParent.colSpan=p+u,s(""),o.end()),d(m,null,e+1,(e=>{o.begin(o.th()),o.domParent.colSpan=e.span,o.domParent.className="text-right truncate",s(e.key),o.end()})),o.end();o.end(),o.begin(o.tbody()),o.domParent.className="table-fixed xxmin-w-full divide-y divide-gray-200",d(y,r,p,((e,t,r,n)=>{o.begin(o.tr());let a=0,u=0;for(let e=0;e<n;e++)0!=r[e+1].index&&(a=e+1),r[e].special&&e<n&&(u=e);for(let e=Math.max(a,u);e<n;e++){if(0==e&&!r[0].special)continue;o.begin(o.th());let{key:t,span:n,special:p}=r[e];p&&(n-=1),o.domParent.rowSpan=n,o.domParent.className="text-left max-w-sm truncate",p?i(" "):s(t),o.end()}n<p?(o.begin(o.th()),o.domParent.colSpan=1+p-n,o.domParent.className="text-left max-w-sm truncate",s(r[n].key),o.end()):(o.begin(o.th()),o.domParent.className="text-left max-w-sm truncate",s(r[n].key),o.end()),d(m,t,l,((e,t,r)=>{o.begin(o.td()),o.domParent.className="text-right max-w-sm truncate",i(t,r[r.length-1].key),o.end()})),o.end()})),o.end(),o.end(),o.end()}(e.rows,e.cols,e.data,e.template);case"select":return function(e){let t=Object.keys(e);if(!t.length)return i;function n(e,t){e.style.display="inline-block",e.style.border="1px solid black",e.style.padding="1px 10px 1px 10px",e.style.cursor="pointer",t?(e.style.color="white",e.style.background="black"):(e.style.background="white",e.style.color="black")}let i,s=t[0],p={};o.begin(),o.begin(),o.domParent.style.marginBottom="5px";for(let e of t)(p[e]=o.add(r("span",{},e))).onclick=o.local((t=>l(s=e)));function l(){i.innerText="",o.begin(i);for(let e of t)n(p[e],e==s);a(e[s]),o.end()}o.end(),i=o.div(),o.end(),l()}(e.data);case"slider":return function(e){let t=Object.keys(e);if(!t.length)return n;let n,i=0,s=t[i];o.begin(),o.begin(),o.domParent.style.marginBottom="5px";let p=o.add(r("input",{type:"range",min:0,max:t.length-1,value:i}));p.oninput=o.local((e=>u(s=t[i=p.value])));let l=o.add(r("span",{}));function u(){n.innerText="",l.innerText=s,o.begin(n),a(e[s]),o.end()}o.end(),n=o.div(),o.end(),u()}(e.data);case"bar":let t=e.value,n=o.add(r("span",{}));return n.style.display="inline-block",n.style.border="1px solid black",n.style.backgroundColor="#EEEEEE",n.style.width=t+"px",n.style.height="0.7em",n;case"dom":let i=e.type??"span",s=e.props??{},l=e.children??{},u=[];for(let e in l){let t=l[e];"string"==typeof t?u.push(t):u.push(a(t))}return o.add(r(i,s,...u));default:return o.add(p(e))}}o.beg=i,o.begin=e=>{o.beg(),e||(e=""),"string"==typeof e&&(e=o.styled(e)),o.domParent=e},o.add=e=>(o.domParent.appendChild(e),e),o.div=function(...e){return o.add(r("div",{},...e))},o.styled=function(e,...t){return o.add(r("div",{className:e},...t))},o.li=function(...e){return o.add(r("li",{},...e))},o.pre=function(e,...t){return o.add(r("pre",{className:e},...t))},o.img=function(e,t,n){return o.add(r("img",{className:e,src:t,alt:n}))},o.link=function(e,t,...n){return o.add(r("a",{className:e,href:t},...n))},o.button=function(e,...t){return o.add(r("button",{className:e},...t))},o.input=function(e,...t){return o.add(r("input",{className:e},...t))},o.table=function(...e){return o.add(r("table",{},...e))},o.thead=function(...e){return o.add(r("thead",{},...e))},o.tbody=function(...e){return o.add(r("tbody",{},...e))},o.col=function(...e){return o.add(r("col",{},...e))},o.th=function(...e){return o.add(r("th",{},...e))},o.td=function(...e){return o.add(r("td",{},...e))},o.tr=function(...e){return o.add(r("tr",{},...e))},o.domParent=t,a(e)}},621:(__unused_webpack_module,exports,__webpack_require__)=>{const{quoteVar,debug,trace,print,inspect,error,warn}=__webpack_require__(798),{scc}=__webpack_require__(60),{runtime}=__webpack_require__(696);function buildDeps(e,t,r){let n=[],o={},i={},s={};for(let t in e){let r=e[t];i[r.writeSym]??=[],o[n.length]??={},i[r.writeSym].push(t),n.push({type:"stmt",val:r}),s[t]=n.length-1}let p={};for(let e in i){let t=i[e];p[e]=s[t.at(-1)]}let a={};for(let e of t)a[e.sym]??=[],a[e.sym].push(e);let l={};for(let e in a)o[n.length]??={},n.push({type:"gen",val:e,data:a[e]}),l[e]=n.length-1;let u=e=>!f(e),f=e=>e.startsWith("tmp");for(let t in e){let r=s[t],n=e[t];for(let e of n.deps)u(e)&&(o[r][l[e]]=!0),f(e)&&(o[r][p[e]]=!0)}for(let e in i){let t=i[e];for(let e in t)if(e>0){let r=s[t[e-1]],n=s[t[e]];o[n][r]=!0}}for(let e in a){let t=a[e],r=l[e];for(let e of t)for(let t of e.deps)u(t)&&(o[r][l[t]]=!0),f(t)&&(o[r][p[t]]=!0)}let m=scc(Object.keys(o),(e=>Object.keys(o[e]))).reverse();for(let e of m)e.length>1&&console.error("cycle!");let y={},d={},c=(e,t,r,n)=>{if(e!=t){if(r[e][t])return;r[e][t]=!0}for(let i in o[t])o[t][i]&&n(e,t,i)&&c(e,i,r,n)},g=(e,t,r)=>!0,h=(e,t,r)=>"gen"===n[r].type;for(let e in o)if("stmt"===n[e].type){y[e]={},c(e,e,y,g);for(let t in y[e])"stmt"!==n[t].type&&delete y[e][t];d[e]={},c(e,e,d,h);for(let t in d[e])delete d[e][t],d[e][n[t].val]=!0}let x={},k={},v=Object.keys(y).map((e=>n[e].val.deps.filter((e=>u(e)))));for(let e in y){x[e]={},k[e]={};let t=v[e];for(let r in y[e])if(x[e][r]={},k[e][r]={},n[r].val.writeSym!=n[e].val.writeSym){let n=v[r];for(let o of n)if(!t.includes(o)){x[e][r][o]=!0;for(let i of t)n.includes(i)||(k[e][r][i]??={},k[e][r][i][o]=!0)}}}return{nodes:n,assignByTmp:i,gensBySym:a,stmtdeps:y,loopdeps:d,stmt2stmtByLoop:x,stmt2stmtloopAfterloop:k,assign2Node:s,tmp2Node:p,gen2Node:l}}exports.generate=(ir,backend="js")=>{let assignmentStms=ir.assignmentStms,generatorStms=ir.generatorStms,tmpVarWriteRank=ir.tmpVarWriteRank,deps=buildDeps(assignmentStms,generatorStms,tmpVarWriteRank),nodes=deps.nodes,stmtdeps=deps.stmtdeps,loopdeps=deps.loopdeps,assignByTmp=deps.assignByTmp,gensBySym=deps.gensBySym,stmt2stmtByLoop=deps.stmt2stmtByLoop,stmt2stmtloopAfterloop=deps.stmt2stmtloopAfterloop,res=ir.res,prolog=ir.prolog,epilog=ir.epilog,explain={};explain.src=ir.query;let code=[],indent=0;function emit(e){if(0==e.indexOf("}")&&indent--,code.push("".padEnd(4*indent," ")+e),0!=e.indexOf("}")){let t=(e.match(/{/g)||[]).length,r=(e.match(/}/g)||[]).length;t>r&&indent++,t<r&&indent--}}if("cpp"==backend||"c-sql"==backend)prolog.forEach(emit);else{if("js"!=backend)return void console.error(`unsupported backend : ${backend}`);emit("inp => {"),emit("let tmp = {}")}if(debug){print("---- begin code ----");for(let e of assignmentStms)e.txt.indexOf("??=")<0&&print(e.txt+"  // "+e.writeSym+" #"+e.writeRank+" <- "+e.deps);print("return "+res.txt),print("---- end code ----")}explain.ir={},explain.ir.assignments=[...assignmentStms],explain.ir.generators=[...generatorStms],explain.dependencies={nodes,stmtdeps,loopdeps,stmt2stmtByLoop},debug&&(inspect({stmtdeps}),print("---- end dependency data ----"));let openedLoops=[],emittedStmts={},closedLoopByStmt={};for(let e in stmtdeps)closedLoopByStmt[e]??={};let isloop=e=>!istmp(e),istmp=e=>e.startsWith("tmp"),getStmt=e=>assignmentStms[e],makeUnique=e=>e.filter((function(t,r){return e.indexOf(t)==r})),getLoops=e=>makeUnique(e.deps.filter(isloop)),isOpened=e=>openedLoops.includes(e);function stmtClosed(e,t){return Object.keys(stmt2stmtByLoop[e][t]).every((e=>closedLoopByStmt[t][e]))}let stmtEmitted=e=>emittedStmts[e];function stmtAvailable(e,t){return stmtEmitted(t)&&stmtClosed(e,t)}function stmtDepsEmitted(e){return Object.keys(stmtdeps[e]).every(stmtEmitted)}function stmtDepsAvailable(e){return Object.keys(stmtdeps[e]).every((t=>stmtAvailable(e,t)))}function inLoops(e){return getLoops(getStmt(e)).every(isOpened)}function stmtEmittable(e){return inLoops(e)&&stmtDepsAvailable(e)}function filterDepsAvailable(e){return e.filter((e=>stmtDepsAvailable(e)))}function filterEmittable(e){return e.filter((e=>stmtEmittable(e)))}function filterNotEmittable(e){return e.filter((e=>!stmtEmittable(e)))}function loopEmittable(e){return!isOpened(e)&&gensBySym[e].every((t=>getLoops(t).every((t=>t===e||isOpened(t)))))}function emitStatement(e){let t=getStmt(e);"c-sql"==backend?t.txt.map(emit):emit(t.txt),emittedStmts[e]=!0;for(let r of t.deps)isloop(r)&&(closedLoopByStmt[e][r]=!1)}function emitLoopProlog(e){let[t,...r]=gensBySym[e];if("cpp"==backend)emit(t.loopTxt);else if("c-sql"==backend){let t=gensBySym[e].map((e=>e.getLoopTxt()));for(let e of t)e.loadCSV.map(emit);for(let e of t)e.initCursor.map(emit);for(let e of t)e.info.map(emit);t[0].loopHeader.map(emit);for(let e of t)e.boundsChecking.map(emit);for(let e of t)e.rowScanning.map(emit)}else{if("js"!=backend)return void console.error(`unsupported backend : ${backend}`);emit("for (let "+quoteVar(t.sym)+" in "+t.rhs+") {");for(let e of r)emit("if ("+e.rhs+"["+quoteVar(e.sym)+"] === undefined) continue")}openedLoops.push(e)}function emitLoopEpilog(){l=openedLoops.pop(),emit("}");for(let e in closedLoopByStmt)getStmt(e).deps.includes(l)&&!1===closedLoopByStmt[e][l]&&(closedLoopByStmt[e][l]=!0)}function nextLoop(e,t){let r,n={},o={};for(let r of e){let e=loopdeps[r];for(let i in e)loopEmittable(i)&&(o[i]??=0,o[i]+=1,t.includes(r)&&(n[i]??=0,n[i]+=1))}let i=Object.keys(n);if(0===i.length)return r;let s={};for(let t of e)for(let r of e)if(r in stmt2stmtloopAfterloop[t])for(let e in stmt2stmtloopAfterloop[t][r])for(let n in stmt2stmtloopAfterloop[t][r][e])isOpened(e)||isOpened(n)||(s[e]??={},s[e][n]=!0);let p=i.filter((e=>void 0===s[e]||0===Object.keys(s[e]).length));0===p.length&&(p=i);for(let e of p)r??=e,l=r,(n[a=e]>n[l]||n[a]===n[l]&&o[a]>o[l])&&(r=e);var a,l;return r}function emitCode(e){for(;filterDepsAvailable(e).length>0;){let t=filterEmittable(e);for(e=filterNotEmittable(e);t.length>0;)t.forEach(emitStatement),t=filterEmittable(e),e=filterNotEmittable(e);if(0==e.length)return e;let r=filterDepsAvailable(e);if(0==r.length)return e;let n=nextLoop(e,r);if(void 0===n)throw new Error("No emittable loops");emitLoopProlog(n);let o=e.filter((e=>loopdeps[e][n])),i=emitCode(o);if(emitLoopEpilog(),o.length==i.length)throw new Error("No progress");e=e.filter((e=>!o.includes(e)||i.includes(e)))}return e}let stmts=Object.keys(assignmentStms);if(stmts=emitCode(stmts),stmts.length>1){warn("ERROR - couldn't emit the following assignments (most likely due to circular dependencies:");for(let e of stmts){let t=getStmt(e);warn(t.txt+" ---- "+t.deps)}console.error("remaining assignments")}if("cpp"==backend||"c-sql"==backend){epilog.forEach(emit);let e=code.join("\n");return e}if("js"==backend){emit("return "+res.txt),emit("}"),trace&&code.forEach((e=>print(e)));let codeString=code.join("\n"),rt=runtime,queryFunc=eval(codeString);return queryFunc.explain=explain,queryFunc.explain.code=code,queryFunc.explain.codeString=codeString,queryFunc}console.error(`unsupported backend : ${backend}`)}},612:(e,t,r)=>{const{desugar:n}=r(824);function o(e){return{xxpath:"ident",xxparam:e}}function i(e,t){return{xxpath:"get",xxparam:[e,t]}}function s(e,t){return{xxpath:"apply",xxparam:[e,t]}}let p={"|":"pipe","&":"and","||":"orElse","&&":"andAlso","<":"lessThan","<=":"lessThanOrEqual",">":"greaterThan",">=":"greaterThanOrEqual","==":"equal","!=":"notEqual","+":"plus","-":"minus","*":"times","/":"fdiv","//":"div","%":"mod"};function a(e,t,r){return{xxpath:p[e]??e,xxparam:[t,r]}}t.rh=(e,...r)=>n(t.parserImpl(e,r)),t.parse=e=>n(t.parserImpl([e],[])),t.parserImpl=(e,t)=>{let r,n,p,l,u,f,m=e.join("\0"),y=0,d=-1,c={};for(let e of"+-*/%<>=!?|&^~")c[e]=1;function g(){let e=r;return n=x(),h(),e}function h(){let e=()=>"0"<=m[y]&&m[y]<="9",t=()=>"a"<=m[y]&&m[y]<="z"||"A"<=m[y]&&m[y]<="Z",n=()=>c[m[y]];if(l=y,e()){for(;e();)y++;r="num"}else if(t()||"_"==m[y]){for(;t()||e()||"_"==m[y];)y++;r="ident"}else if("*"==m[y]){for(;"*"==m[y];)y++;if(t()||e()||"_"==m[y]){for(;t()||e()||"_"==m[y];)y++;r="ident"}else{for(;n();)y++;r=m.substring(l,y)}}else if(n()){for(;n();)y++;r=m.substring(l,y)}else if('"'==m[y]){for(y++;m[y]&&"\n"!=m[y]&&'"'!=m[y];)y++;'"'==m[y]&&y++,r="str"}else"\n"==m[y]?(r=m[y++],u=x(!0),"-"==m[y]&&" "==m[y+1]?(y+=2,f=!0,u+=2):f=!1,g()):"\0"===m[y]?(y+=1,d+=1,r="hole"):r=m[y++];p=m.substring(l,y)}function x(e){let t=y;for(;" "==m[y];)++y;let r=y;if("/"==m[y]&&"/"==m[y+1])for(y+=2;m[y]&&"\n"!=m[y];)++y;else if("#"==m[y])for(y+=1;m[y]&&"\n"!=m[y];)++y;return e?r-t:y-t}function k(e){throw console.dir({start:l,pos:y,str:p,msg:e}),new Error(e)}function v(e){"("!=r&&k("'(' expected"),g();let t=e();return")"!=r&&k("')' expected but got '"+r+"'"),g(),t}function b(e){"["!=r&&k("'[' expected"),g();let t=e();return"]"!=r&&k("']' expected but got '"+r+"'"),g(),t}u=n=x(),"-"==m[y]&&" "==m[y+1]?(y+=2,f=!0):f=!1,h();let S={"|":40,"&":50,"||":70,"&&":80,"<":90,"<=":90,">":90,">=":90,"==":90,"!=":90,"+":100,"-":100,"*":200,"/":200,"//":200,"%":200},$={"|":1,"&":1,"||":1,"&&":1,"=":0,"<":1,"<=":1,">":1,">=":1,"==":1,"!=":1,"+":1,"-":1,"*":1,"/":1,"//":1,"%":1};function w(){return q(0)}function _(){return j(50)}function q(e){let t=function(){let e=_();for(;"num"==r||"str"==r||"hole"==r||"ident"==r||"*"==r||"."==r||"("==r||"["==r;)e=s(e,_());return e}();for(;r in S&&S[r]>=e;){let e=S[r]+$[r];t=a(g(),t,q(e))}return t}function j(e){let t=function(){let e;for("."==r?(g(),e=i(E())):e=E();""==n&&("."==r||"("==r||"["==r);)"."==r?(g(),e=i(e,E())):"("==r?e=s(e,v(w)):"["==r&&(e=i(e,b(w)));return e}();for(;r in S&&S[r]>=e;){let e=S[r]+$[r];t=a(g(),t,j(e))}return t}function E(){if("("==r)return v(w);if("num"==r||"str"==r||"ident"==r||"*"==r){let e=p;"str"==r&&e.startsWith('"')&&(e=e.substring(1,e.length),e.endsWith('"')||k("unclosed string literal"),e=e.substring(0,e.length-1));let t="num"==r?{xxpath:"raw",xxparam:e}:o(e);return g(),t}if("hole"==r){let e={xxpath:"hole",xxparam:t[d]};return g(),e}k("{"==r?"object constructor syntax not supported yet":"["==r?"array constructor syntax not supported yet":"atom expected but got '"+r+"'")}let P=w();return y!=m.length+1&&k("couldn't parse '"+r+"'"),P},t.parsePurePath=e=>{let t=e.split(".");if(1==t.length)return o(t[0]);let r={xxpath:"raw",xxparam:"inp"};for(let e=0;e<t.length;e++)""!=t[e]&&(r=i(r,o(t[e])));return r}},353:(e,t,r)=>{const{api:n}=r(32),{parse:o}=r(612),{runtime:i}=r(696);let s=e=>{if(!0===e||!1===e)return{key:"const",op:Boolean(e)};if("number"==typeof e||!Number.isNaN(Number(e)))return{key:"const",op:Number(e)};if("string"==typeof e)return"-"==e||"$display"==e?{key:"const",op:e}:s(o(e));if(void 0===e)return console.error("why undefined?"),e;if("raw"==e.xxpath)return"inp"==e.xxparam?{key:"input"}:Number.isNaN(Number(e.xxparam))?{key:"const",op:e.xxparam}:{key:"const",op:Number(e.xxparam)};if("loadCSV"==e.xxpath){let t=s(e.xxparam);return void 0===e.xxextra&&console.error("csv schema expected"),{key:"loadInput",op:"csv",arg:[t],schema:e.xxextra}}if("ident"==e.xxpath)return e.xxparam.startsWith("*")?{key:"var",op:e.xxparam}:{key:"const",op:e.xxparam};if("get"==e.xxpath){let t,r=s(e.xxparam[0]);return void 0===e.xxparam[1]?(t=r,r={key:"input"}):t=s(e.xxparam[1]),{key:"get",arg:[r,t]}}if("apply"==e.xxpath){let[t,...r]=e.xxparam,n=s(t);return"const"==n.key?s({...e,xxpath:n.op,xxparam:r}):{key:"pure",op:"apply",arg:[n,...r.map(s)]}}if("hint"==e.xxpath){let[t,...r]=e.xxparam,n=s(t);return"const"==n.key?{key:"hint",op:n.op,arg:[...r.map(s)]}:{key:"hint",op:"generic",arg:[n,...r.map(s)]}}if("array"==e.xxkey)return s(e.xxparam);if(e instanceof Array)return 1==e.length?{key:"stateful",op:"array",arg:e.map(s)}:{key:"pure",op:"flatten",arg:e.map((e=>s([e])))};if("object"==typeof e&&!e.xxpath&&!e.xxkey){let t;for(let r of Object.keys(e)){let n=e[r],o=s(r),i=s(n);"merge"!=i.key&&"keyval"!=i.key||(o=i.arg[0],i=i.arg[1]),t=t?{key:"update",arg:[t,o,i]}:{key:"group",arg:[o,i]}}return t||(t={key:"const",op:{}}),t}if(e.xxpath||e.xxkey){let t=e.xxpath||e.xxkey,r=(e.xxpath,e.xxparam instanceof Array?e.xxparam.map(s):[s(e.xxparam)]);if(t in i.special)return{key:t,arg:r};if(t in i.pure)return{key:"pure",op:t,arg:r};if(t in i.stateful||"print"==t)return{key:"stateful",op:t,arg:r};if(t.startsWith("prefix_")&&t.substring(7)in i.stateful)return{key:"prefix",op:t.substring(7),arg:r};console.error("unknown op",e)}else console.error("malformed op",e)};t.preproc=s},32:(e,t,r)=>{let n={};t.api=n,t.pipe=f;const o=r(35),i=r(621),s=r(543),p=r(462),a=r(204),{typing:l}=r(104);n.sum=e=>({xxkey:"sum",xxparam:e}),n.count=e=>({xxkey:"count",xxparam:e}),n.max=e=>({xxkey:"max",xxparam:e}),n.min=e=>({xxkey:"min",xxparam:e}),n.join=e=>({xxkey:"join",xxparam:e}),n.array=(...e)=>({xxkey:"array",xxparam:e}),n.last=e=>({xxkey:"last",xxparam:e}),n.first=e=>({xxkey:"first",xxparam:e}),n.single=e=>({xxkey:"last",xxparam:e}),n.keyval=(e,t)=>({xxkey:"keyval",xxparam:[e,t]}),n.flatten=(e,t)=>({xxkey:"flatten",xxparam:[e,t]}),n.merge=(e,t)=>({xxkey:"merge",xxparam:[e,t]}),n.group=(e,t)=>({_IGNORE_:n.keyval(t,e)}),n.get=(e,t)=>({xxpath:"get",xxparam:[e,t]}),n.apply=(e,t)=>({xxpath:"apply",xxparam:[e,t]}),n.pipe=(e,t)=>({xxpath:"apply",xxparam:[t,e]}),n.plus=(e,t)=>({xxpath:"plus",xxparam:[e,t]}),n.minus=(e,t)=>({xxpath:"minus",xxparam:[e,t]}),n.times=(e,t)=>({xxpath:"times",xxparam:[e,t]}),n.fdiv=(e,t)=>({xxpath:"fdiv",xxparam:[e,t]}),n.div=(e,t)=>({xxpath:"div",xxparam:[e,t]}),n.mod=(e,t)=>({xxpath:"mod",xxparam:[e,t]}),n.and=(e,t)=>({xxpath:"and",xxparam:[e,t]});let u={sum:function(){return f(n.sum(this))},count:function(){return f(n.count(this))},max:function(){return f(n.max(this))},first:function(){return f(n.first(this))},last:function(){return f(n.last(this))},group:function(e){return f(n.group(this,e))},map:function(e){return f(n.apply(e,this))},get:function(e){return f(n.get(this,e))}};function f(e){"string"==typeof e&&(e=n.get(e));let t=Object.create(u);for(let r in e)t[r]=e[r];return t}n.show=(e,t,r)=>{let o=n.query(e);return display(o(t))},n.exec=(e,t)=>n.query(e)(t),n.query=n.compile=(e,t=l.any)=>{let r=s.createIR(e),n=o.generate(r),p=i.generate(r),u=a.compile(e,{schema:t}),f=a.compile(e,{schema:t,newCodegen:!0}),m=e=>{let t=n(e),r=p(e),o=u(e),i=f(e),s=e=>({toEqual:t=>{let r=JSON.stringify(e),n=JSON.stringify(t);console.assert(r==n,"result mismatch")}});try{s=expect}catch(e){}return s(r).toEqual(t),s(o).toEqual(t),s(i).toEqual(o),o};return m.c1=n,m.c1_opt=p,m.c2=u,m.c2_new=f,m.explain=n.explain,m.explain_opt=p.explain,m.explain2=u.explain,m.explain2_new=f.explain,m},n.compileC1=n.compileFastPathOnly=e=>{let t=s.createIR(e),r=o.generate(t),n=i.generate(t),p=e=>{let t=r(e),o=n(e),i=e=>({toEqual:t=>{let r=JSON.stringify(e),n=JSON.stringify(t);console.assert(r==n,"result mismatch")}});try{i=expect}catch(e){}return i(o).toEqual(t),t};return p.c1=r,p.c1_opt=n,p.explain=r.explain,p.explain_opt=n.explain,p},n.compileNew=e=>{let t=s.createIR(e),r=i.generate(t),n=a.compile(e),o=a.compile(e,{newCodegen:!0}),p=e=>{let t=r(e),i=n(e),s=o(e),p=e=>({toEqual:t=>{let r=JSON.stringify(e),n=JSON.stringify(t);console.assert(r==n,"result mismatch")}});try{p=expect}catch(e){}return p(i).toEqual(t),p(s).toEqual(i),i};return p.c1=r,p.c2=n,p.c2_new=o,p.explain=r.explain,p.explain2=n.explain,p.explain2_new=o.explain,p},n.compileC2=e=>{s.createIR(e);let t=a.compile(e),r=a.compile(e,{newCodegen:!0}),n=e=>{let n=t(e),o=r(e),i=e=>({toEqual:t=>{let r=JSON.stringify(e),n=JSON.stringify(t);console.assert(r==n,"result mismatch")}});try{i=expect}catch(e){}return i(o).toEqual(n),n};return n.c2=t,n.c2_new=r,n.explain=t.explain,n.explain2=t.explain,n.explain2_new=r.explain,n},n.display=(e,t)=>p.display(e,t)},60:(e,t)=>{function*r(e){let t=e.length;for(;0<t;)yield e[--t]}t.scc=function(e,t){let n=0,o=[],i={},s=[];function p(e){if(i[e])return i[e];i[e]=++n,o.push(e);let a=n;for(let n of r(t(e)??[])){let e=p(n);e<a&&(a=e)}if(a==i[e]){let t=[];for(;;){let r=o.pop();if(t.push(r),i[r]=Number.MAX_SAFE_INTEGER,r==e)break}s.push(t.reverse())}return a}for(let t of r(e))p(t);return s.reverse()}},204:(__unused_webpack_module,exports,__webpack_require__)=>{const{api}=__webpack_require__(32),{parse}=__webpack_require__(612),{scc}=__webpack_require__(60),{generate}=__webpack_require__(621),{preproc}=__webpack_require__(353),{runtime}=__webpack_require__(696),{generateCSql}=__webpack_require__(551),{generateCSqlNew}=__webpack_require__(479),{typing,types,typeSyms}=__webpack_require__(104);let unique=e=>e.filter(((t,r)=>e.indexOf(t)==r)),union=(e,t)=>unique([...e,...t]),intersect=(e,t)=>{let r={},n=[];for(let e of t)r[e]=!0;for(let t of e)r[t]&&n.push(t);return n},diff=(e,t)=>{let r={},n=[];for(let e of t)r[e]=!0;for(let t of e)r[t]||n.push(t);return n},subset=(e,t)=>{let r={};for(let e of t)r[e]=!0;for(let t of e)if(!r[t])return!1;return!0},same=(e,t)=>subset(e,t)&&subset(t,e),traverse=(...e)=>t=>r=>{if(console.assert(e.length>0),0==t)return r([],...e);let[n,...o]=e;for(let i in n)o&&!o.every((e=>i in e))||traverse(...e.map((e=>e[i])))(t-1)(((e,...t)=>{r([i,...e],...t)}))},update=e=>t=>r=>{if(void 0===r)return e;if(t.length>0){let[n,...o]=t;return e??={},e[n]=update(e[n]??{})(o)(r),e}return r},reshape=e=>(t,r)=>{console.assert(same(t,r));let n=r.map((e=>t.indexOf(e))),o={};return traverse(e)(t.length)(((e,t)=>{let r=n.map((t=>e[t]));o=update(o)(r)(t)})),o},join=(e,t)=>(r,n,o)=>i=>{let s=r,p=n,a=o,l=e,u=t;console.assert(subset(s,a)),console.assert(subset(p,a)),console.assert(same(a,union(s,p)));let f=diff(a,p),m=diff(a,s),y=intersect(s,p);l=reshape(l)(s,[...f,...y]),u=reshape(u)(p,[...m,...y]);let d={};return traverse(l)(f.length)(((e,t)=>traverse(u)(m.length)(((r,n)=>{traverse(t,n)(y.length)(((t,n,o)=>{d=update(d)([...e,...r,...t])(i(n,o))}))})))),d=reshape(d)([...f,...m,...y],a),d},defaultSettings={altInfer:!1,antiSubstGroupKey:!1,singleResult:!0,extractAssignments:!0,extractFilters:!0,newCodegen:!1,backend:"js",schema:typing.any,outDir:"cgen-sql",outFile:"tmp.c"},settings,prefixes,path,vars,hints,filters,assignments,reset=e=>{settings={...defaultSettings,...e},prefixes=[],path=[],vars={},hints=[],filters=[],assignments=[]},isVar=e=>e.startsWith("*"),canonicalVarName=(e,t)=>{let r=JSON.stringify(e),n=prefixes.indexOf(r);return n<0&&(n=prefixes.length,prefixes.push(r)),(t?"K":"D")+n},extractFlex0=e=>"stateful"==e.key||"group"==e.key||"update"==e.key?extract0(e):extract0({key:"stateful",op:"single",mode:"reluctant",arg:[e]}),extractKey0=e=>"var"==e.key&&"*WILDCARD"==e.op?{key:"placeholder",op:"*",arg:[]}:extract0(e),extract0=e=>{if("var"==e.key){if("*"==e.op)throw console.error("cannot support free-standing *");return e}if("get"==e.key){let[t,r]=e.arg;return"var"==r.key&&"*"==r.op&&(r={...r,op:canonicalVarName(t,!1)}),t=extract0(t),r=extract0(r),{...e,arg:[t,r]}}if("group"==e.key){let t=[{key:"const",op:{}}];return 1==e.arg.length&&t.push({key:"placeholder",op:"*",arg:[]}),t.push(...e.arg),extract0({...e,key:"update",arg:t})}if("update"==e.key||"update_inplace"==e.key){let t=extract0(e.arg[0]),r=extractKey0(e.arg[1]),n=extractFlex0(e.arg[2]);if("var"!=r.key&&"placeholder"!=r.key){let o={key:"mkset",arg:[r]},i={key:"var",op:canonicalVarName(o,!0)},s={key:"var",op:canonicalVarName(o,!0)};return{...e,arg:[t,i,n,{key:"get",arg:[o,s]}],mode:n.mode}}return{...e,arg:[t,r,n],mode:n.mode}}if(e.arg){let t=e.arg.map(extract0);return{...e,arg:t}}return e},extract0b=(e,t)=>{if(!prefixes.length)return e;if("stateful"==e.key&&"reluctant"!=e.mode)e.arg=e.arg.map((e=>extract0b(e,[])));else if("update"==e.key){let[r,n,o,i]=e.arg;r=extract0b(r,t),o="var"==n.key&&n.op.startsWith("K")?extract0b(o,union(t,[n.op])):extract0b(o,t),i?(i=extract0b(i,t),e.arg=[r,n,o,i]):e.arg=[r,n,o]}else e.arg&&(e.arg=e.arg.map((e=>extract0b(e,t))));if(!t.length)return e;let r={key:"mkset",arg:[e]},n=JSON.stringify(r),o=prefixes.indexOf(n);return o>=0&&subset(["K"+o],t)?{key:"var",op:"K"+o}:e},extract1=e=>{if(e.arg&&e.arg.map(extract1),"var"==e.key)vars[e.op]??={vars:[],vars1:[]};else if("get"==e.key){let[t,r]=e.arg;"var"==r.key&&(vars[r.op].vars=union(vars[r.op].vars,t.dims),vars[r.op].vars1=union(vars[r.op].vars1,t.dims))}},varsChanged=!1,extract1f=e=>{if(e.arg&&e.arg.map(extract1f),"var"==e.key)vars[e.op]??={},vars[e.op].varsf??=[],vars[e.op].varsf1??=[];else if("get"==e.key){let[t,r]=e.arg;"var"==r.key&&(subset(t.fre??t.dims,vars[r.op].varsf)||(varsChanged=!0,vars[r.op].varsf=union(vars[r.op].varsf,t.fre??t.dims),vars[r.op].varsf1=union(vars[r.op].varsf1,t.fre??t.dims)))}},extract2=e=>{if(!e.arg)return{...e,tmps:[]};let t=e.arg.map(extract2),r=unique(t.flatMap((e=>e.tmps)));if("prefix"==e.key||"stateful"==e.key||"update"==e.key){let n={...e,arg:t,tmps:r},o=JSON.stringify(n),i=assignments.map(JSON.stringify).indexOf(o);return i<0&&(i=assignments.length,assignments.push(n)),{...e,key:"ref",op:i,arg:[],tmps:[i]}}return{...e,arg:t,tmps:r}},extract3=e=>{if(e.arg){if(e.arg.map(extract3),e.filters=unique(e.arg.flatMap((e=>e.filters??[]))),"get"==e.key){let[t,r]=e.arg;if("var"==r.key){let t=JSON.stringify(e),r=filters.map(JSON.stringify).indexOf(t);if(r<0){r=filters.length;let e=JSON.parse(t);filters.push(e)}e.filter=r,e.filters.push(r)}}if("hint"==e.key){let t=JSON.stringify(e),r=hints.map(JSON.stringify).indexOf(t);if(r<0){r=hints.length;let e=JSON.parse(t);hints.push(e)}e.hint=r}}},inferDims=e=>{if("input"==e.key||"const"==e.key||"placeholder"==e.key)e.vars=[],e.mind=[],e.dims=[];else if("var"==e.key)e.vars=[e.op],e.mind=[e.op],e.dims=[e.op];else if("get"==e.key||"pure"==e.key||"hint"==e.key||"mkset"==e.key||"loadInput"==e.key){let t=e.arg.map(inferDims);e.vars=unique(t.flatMap((e=>e.vars))),e.mind=unique(t.flatMap((e=>e.mind))),e.dims=unique(t.flatMap((e=>e.dims))),"get"==e.key&&(e.dims=union(t[0].mind,t[1].dims))}else if("stateful"==e.key||"prefix"==e.key){let[t]=e.arg.map(inferDims);e.vars=t.vars,e.mind=[],"reluctant"==e.mode?e.dims=t.dims:e.dims=[]}else if("update"==e.key||"update_inplace"==e.key){let[t,r,n,o]=e.arg.map(inferDims);o??={vars:[],mind:[],dims:[]},"update_inplace"==e.key&&(e.mode="inplace",e.key="update"),e.vars=unique([...t.vars,...r.vars,...n.vars,...o.vars]),"placeholder"==r.key?(e.mind=[],e.dims=t.dims):(e.mind=union(t.mind,diff(n.mind,r.vars)),e.dims=union(t.dims,diff(n.dims,r.vars)))}else console.error("unknown op",e);return console.assert(subset(e.mind,e.dims)),console.assert(subset(e.dims,e.vars)),e},isCorrelatedKeyVar=e=>e.startsWith("K")||e.startsWith("*KEYVAR"),trans=e=>unique([...e,...e.flatMap((e=>vars[e].vars))]),trans1=e=>unique(e.flatMap((e=>vars[e].vars))),transf=e=>unique([...e,...e.flatMap((e=>vars[e].varsf))]),transf1=e=>unique(e.flatMap((e=>vars[e].varsf1))),intersects=(e,t)=>intersect(e,t).length>0,overlaps=(e,t)=>intersects(trans(e),trans(t)),assertSame=(e,t,r)=>console.assert(same(e,t),r+": "+e+" != "+t),inferBound=e=>t=>{if("input"==t.key||"const"==t.key||"placeholder"==t.key)t.bnd=[];else if("var"==t.key)t.bnd=[];else if("get"==t.key||"pure"==t.key||"hint"==t.key||"mkset"==t.key||"loadInput"==t.key)t.arg.map(inferBound(e)),t.bnd=[];else if("stateful"==t.key||"prefix"==t.key){let r=union(e,t.arg[0].dims),[n]=t.arg.map(inferBound(r));t.bnd=diff(n.dims,e)}else if("update"==t.key){inferBound(e)(t.arg[0]);let r,n=inferBound(e)(t.arg[1]);if("placeholder"==n.key){let r=diff(t.arg[2].dims,e);n=t.arg[1]={key:"pure",op:"vars",arg:r.map((e=>({key:"var",op:e,arg:[],vars:[e],mind:[e],dims:[e],bnd:[]}))),vars:r,mind:r,dims:r,bnd:[]}}if(t.arg[3]){let o=union(e,union([n.op],t.arg[3].dims)),i=inferBound(o)(t.arg[3]);console.assert("get"==i.key),console.assert("mkset"==i.arg[0].key),console.assert("var"==i.arg[1].key&&i.arg[1].op==n.op),r=i.arg[0].arg[0]}else r={key:"const",op:"???",vars:[],mind:[],dims:[],bnd:[]};t.e1BodyBnd=diff(r.dims,e),inferBound(union(e,n.vars))(t.arg[2]),t.bnd=diff(union(n.vars,[]),e)}else console.error("unknown op",t);return console.assert(subset(t.mind,t.dims)),console.assert(subset(t.dims,t.vars)),t},checkDimsFreeTrans=!1,inferFree=e=>t=>{if("input"==t.key||"const"==t.key||"placeholder"==t.key)t.fre=[];else if("var"==t.key)console.assert(subset([t.op],e)||isCorrelatedKeyVar(t.op)),t.fre=[t.op];else if("get"==t.key||"pure"==t.key||"hint"==t.key||"mkset"==t.key||"loadInput"==t.key){let r=t.arg.map(inferFree(e));t.fre=unique(r.flatMap((e=>e.fre)))}else if("stateful"==t.key||"prefix"==t.key){let r=union(e,t.arg[0].dims);assertSame(r,union(e,t.bnd));let[n]=t.arg.map(inferFree(r)),o=path.filter((e=>intersects(trans(e.xxFree),trans(t.bnd)))).flatMap((e=>e.xxFree)),i=e.filter(isCorrelatedKeyVar).filter((r=>intersects(diff(transf([r]),e),transf(t.bnd))));checkDimsFreeTrans&&assertSame(o,diff(i,["*KEYVAR"]),"extra "+pretty(t)),o=i,t.fre=intersect(union(trans(t.bnd),union(n.fre,o)),e);let s=intersect(union(n.fre,union(transf(t.bnd),o)),e);checkDimsFreeTrans&&assertSame(t.fre,s,"FRE1.1 "+pretty(t)),t.fre=s}else if("update"==t.key){let r,n=inferFree(e)(t.arg[0]),o=inferFree(union(e,t.arg[1].dims))(t.arg[1]);if(t.arg[3]){let n=union(e,union([],diff(t.arg[3].dims,[o.op]))),i=inferFree(n)(t.arg[3]);console.assert("get"==i.key),console.assert("mkset"==i.arg[0].key),console.assert("var"==i.arg[1].key&&i.arg[1].op==o.op),r=i.arg[0].arg[0]}else r={key:"const",op:"???",vars:[],mind:[],dims:[],fre:[]};let i=path;t.arg[3]&&(path=[...path,{xxFree:o.vars}]);let s=inferFree(union(e,o.vars))(t.arg[2]);path=i;let p=path.filter((e=>intersects(trans(e.xxFree),trans(t.bnd)))).flatMap((e=>e.xxFree)),a=e.filter(isCorrelatedKeyVar).filter((r=>intersects(diff(transf([r]),e),transf(t.bnd))));checkDimsFreeTrans&&assertSame(p,diff(a,["*KEYVAR"]),"extra2 "+pretty(t)),p=a;let l=unique([...n.fre,...o.fre,...s.fre,...diff(r.fre,t.e1BodyBnd)]);t.fre=intersect(union(trans(t.bnd),union(l,p)),e);let u=intersect(union(l,union(transf(t.bnd),p)),e);checkDimsFreeTrans&&assertSame(t.fre,u,"FRE2.1 "+pretty(t)),t.fre=u}else console.error("unknown op",t);return console.assert(subset(t.mind,t.dims)),console.assert(subset(t.dims,t.vars)),console.assert(!intersects(t.fre,t.bnd)),t},deno=e=>t=>{if("input"==e.key){let{out:r}=t({vars:[],dims:[]});return e.real=[],pretty(e)}if("const"==e.key){let{out:r}=t({vars:[],dims:[]});return e.real=[],pretty(e)}if("var"==e.key){let{out:r}=t({vars:[e.op],dims:[e.op]});return e.real=[e.op],pretty(e)}if("get"==e.key||"pure"==e.key){console.assert(2==e.arg.length);let[r,n]=e.arg;return deno(r)((r=>(deno(n)((n=>{let{out:o}=t({vars:union(r.vars,n.vars),dims:union(r.dims,n.dims)});return e.out=o,{out:e.out}})),{out:e.out}))),e.real=union(r.real,n.real),pretty(e)}if("stateful"==e.key){console.assert(1==e.arg.length);let[r]=e.arg;return deno(r)((r=>{let{out:n}=t({vars:r.vars,dims:[]});return e.out=n,{out:union(e.out,r.dims)}})),e.real=intersect(e.out,r.real),console.log("SUM",r.real+"->"+e.real+" / "+e.out," --- ",pretty(e)),pretty(e)}console.error("unknown op",e)},computeDependencies=()=>{let e={var2var:{}},t=(r,n)=>{if(!e.var2var[r][n]){e.var2var[r][n]=!0;for(let e of vars[n].vars)t(r,e)}};for(let r in vars){e.var2var[r]??={};for(let e of vars[r].vars)t(r,e)}for(let t in e.var2var)vars[t].vars=Object.keys(e.var2var[t])},computeDependenciesf=()=>{let e={var2var:{}},t=(r,n)=>{if(!e.var2var[r][n]){e.var2var[r][n]=!0;for(let e of vars[n].varsf)t(r,e)}};for(let r in vars){e.var2var[r]??={};for(let e of vars[r].varsf)t(r,e)}for(let t in e.var2var)vars[t].varsf=Object.keys(e.var2var[t])},computeOrder=e=>{if(0==assignments.length)return[];let t={var2var:{},var2tmp:{},tmp2var:{},tmp2tmp:{}};for(let e in vars)t.var2var[e]={},t.var2tmp[e]={};for(let e in assignments){t.tmp2var[e]={},t.tmp2tmp[e]={};let r=assignments[e];for(let n of union(r.fre,r.bnd))t.tmp2var[e][n]=!0;for(let n of r.tmps)t.tmp2tmp[e][n]=!0}for(let e in filters){let r=filters[e],n=r.arg[1].op;r=r.arg[0];for(let e of r.fre)t.var2var[n][e]=!0;for(let e of r.tmps)t.var2tmp[n][e]=!0}let r={tmp2tmp:{}};for(let e in t.tmp2tmp){r.tmp2tmp[e]={};for(let n in t.tmp2tmp[e])r.tmp2tmp[e][n]=!0;for(let n in t.tmp2var[e])for(let o in t.var2tmp[n])r.tmp2tmp[e][o]=!0}return scc(Object.keys(r.tmp2tmp),(e=>Object.keys(r.tmp2tmp[e]))).reverse()},prettyPath=e=>void 0===e?"[?]":"["+e.map((e=>"string"==typeof e?e:pretty(e))).join(",")+"]",pretty=e=>{if("input"==e.key)return"inp";if("loadInput"==e.key){let[t]=e.arg.map(pretty);return`loadInput('${e.op}', ${t})`}if("const"==e.key)return"object"==typeof e.op&&0==Object.keys(e.op).length?"{}":""+e.op;if("var"==e.key)return e.op;if("ref"==e.key){let t=assignments[e.op];return"tmp"+e.op+prettyPath(t.fre)}if("get"==e.key){let[t,r]=e.arg.map(pretty);return"inp"==t?r:t+"["+r+"]"}if("pure"==e.key){let t=e.arg.map(pretty);return e.op+"("+t.join(", ")+")"}if("hint"==e.key){let t=e.arg.map(pretty);return e.op+"("+t.join(", ")+")"}if("mkset"==e.key){let[t]=e.arg.map(pretty);return"mkset("+t+")"}if("prefix"==e.key){let[t]=e.arg.map(pretty);return"prefix_"+e.op+"("+t+")"}if("stateful"==e.key){let[t]=e.arg.map(pretty);return e.op+"("+t+")"}if("group"==e.key){let[t,r]=e.arg.map(pretty);return"{ "+t+": "+r+" }"}if("update"==e.key){let[t,r,n,o]=e.arg.map(pretty);return o?t+"{ "+r+": "+n+" } / "+o:t+"{ "+r+": "+n+" }"}console.error("unknown op",e)},pseudoVerbose=!1,emitPseudo=e=>{let t=16,r=[];for(let e in filters){let n=filters[e];r.push(("gen"+e+prettyPath(n.fre)).padEnd(t)+" = "+pretty(n)),r.push("".padEnd(t)+" : "+typing.prettyPrintTuple(n.schema)),pseudoVerbose&&n.fre.length&&r.push("  "+n.fre)}hints.length&&r.push("");for(let e in hints){let n=hints[e];r.push(("hint"+e+prettyPath(n.fre)).padEnd(t)+" = "+pretty(n)),r.push("".padEnd(t)+" : "+typing.prettyPrintTuple(n.schema)),pseudoVerbose&&n.fre.length&&r.push("  "+n.fre)}if(pseudoVerbose){r.push(""),r.length;for(let e in vars)(vars[e].vars.length>0||vars[e].tmps&&vars[e].tmps.length>0)&&r.push(e+" -> "+vars[e].vars+"  "+(vars[e].tmps??[]))}r.push(""),hi=r.length;for(let e in vars)(vars[e].varsf.length>0||vars[e].tmps&&vars[e].tmps.length>0)&&r.push(e+" -> "+vars[e].varsf+"  "+(vars[e].tmps??[]));r.length>hi&&r.push("");for(let e in assignments){let n=assignments[e];r.push(("tmp"+e+prettyPath(n.fre)+prettyPath(n.bnd)).padEnd(t)+" = "+pretty(n)),r.push("".padEnd(t)+" : "+typing.prettyPrintTuple(n.schema)),pseudoVerbose&&(n.path?.length>0&&r.push("  pth: "+n.path.map(pretty)),n.vars.length>0&&r.push("  var: "+n.vars),n.tmps?.length>0&&r.push("  tmp: "+n.tmps),n.mind.length>0&&r.push("  min: "+n.mind),n.dims.length>0&&r.push("  dim: "+n.dims),n.out?.length>0&&r.push("  out: "+n.out),n.iterInit?.length>0&&r.push("  it0: "+n.iterInit),n.iter?.length>0&&r.push("  itr: "+n.iter),n.free?.length>0&&r.push("  fr1: "+n.free),n.fre?.length>0&&r.push("  fre: "+n.fre),n.bound?.length>0&&r.push("  bn1: "+n.bound),n.bnd?.length>0&&r.push("  bnd: "+n.bnd))}return r.push(pretty(e)),r.push(": "+typing.prettyPrintTuple(e.schema)),e.fre?.length>0&&r.push("  "+e.fre),r.join("\n")},isFresh=e=>"const"==e.key||"pure"==e.key&&"apply"==e.op&&e.arg.slice(1).every(isFresh),isDeepVarStr=e=>e.startsWith("**"),isDeepVarExp=e=>"var"==e.key&&isDeepVarStr(e.op),quoteVar=e=>e.replaceAll("*","x"),quoteIndex=e=>"?.["+e+"]",quoteIndexVars=(e,t)=>e+t.map(quoteVar).map(quoteIndex).join(""),quoteStr=e=>'"'+e+'"',quoteVarXS=e=>isDeepVarStr(e)?quoteVar(e)+".join('-')+'-'":quoteVar(e),quoteIndexVarsXS=(e,t)=>e+t.map(quoteVarXS).map(quoteIndex).join(""),codegen=(e,t)=>{if(console.assert(t.vars),console.assert(t.filters),"input"==e.key)return"inp";if("loadInput"==e.key){console.error("op not implemented: ",pretty(e));let[r]=e.arg.map((e=>codegen(e,t)));return`loadInput('${e.op}', ${r})`}if("const"==e.key){if("string"==typeof e.op)return"'"+e.op+"'";if("object"==typeof e.op&&0==Object.keys(e.op).length)return"{}";{let t=String(e.op);return"[object Object]"==t&&console.error("emit unknown constant: ",e.op),t}}if("var"==e.key)return settings.extractAssignments||t.vars.indexOf(e.op)<0&&(t.buf.push("// ERROR: var '"+e.op+"' not defined in "+t.vars),console.error("// ERROR: var '"+e.op+"' not defined")),quoteVar(e.op);if("ref"==e.key){let t=assignments[e.op],r=[String(e.op),...t.fre];return quoteIndexVarsXS("tmp",r)}if(settings.extractFilters&&"get"==e.key&&"filter"in e&&t.filters.indexOf(e.filter)>=0)return"gen"+e.filter;if("get"==e.key&&isDeepVarExp(e.arg[1])){let[r,n]=e.arg.map((e=>codegen(e,t)));return"rt.deepGet("+r+","+n+")"}if("get"==e.key){let[r,n]=e.arg.map((e=>codegen(e,t)));return r+quoteIndex(n)}if("pure"==e.key){let r=e.arg.map((e=>codegen(e,t)));return"rt.pure."+e.op+"("+r.join(",")+")"}if("hint"==e.key)return"{}";if("mkset"==e.key){let[r]=e.arg.map((e=>codegen(e,t)));return"rt.singleton("+r+")"}return"stateful"!=e.key&&"prefix"!=e.key&&"update"!=e.key?(console.error("unknown op",pretty(e)),"<?"+e.key+"?>"):settings.extractAssignments?void console.error("unexpected nested assignment "+pretty(e)):emitStmInline(e,t)},emitStmInit=(e,t)=>{if("stateful"==e.key)return"rt.stateful."+e.op+"_init";if("update"==e.key){let r=codegen(e.arg[0],t);return"inplace"==e.mode||isFresh(e.arg[0])?"(() => "+r+")":"rt.stateful.update_init("+r+")"}console.error("unknown op",e)},emitStmUpdate=(e,t)=>{if("prefix"==e.key){let[r]=e.arg.map((e=>codegen(e,t)));return"rt.stateful.prefix(rt.stateful."+e.op+"("+r+"))"}if("stateful"==e.key){let[r]=e.arg.map((e=>codegen(e,t)));return"rt.stateful."+e.op+"("+r+")"}if("update"==e.key){let r=codegen(e.arg[0],t),n=codegen(e.arg[2],t);return"rt.stateful.update("+r+", ["+e.arg[1].vars.map(quoteVar)+"], "+n+")"}console.error("unknown op",e)},transViaFiltersFree=e=>{let t={};for(let r of e)t[r]=!0;let r=!1;for(;!r;){r=!0;for(let e in filters){let n=filters[e],o=n.arg[1].op,i=n.arg[0];if(t[o])for(v2 of i.fre)t[v2]||(t[v2]=!0,r=!1)}}let n=[];for(let e in t)n.push(e);return n},emitFilters1=(e,t,r)=>(n,o)=>i=>{let s=diff(union(t,r),e.vars);if(0==s.length)return i(e);let p=transf(union(t,r));if(same(diff(p,e.vars),s))emitFilters2(e,p)(n,o)(i);else{let t="}";n.push("{"),n.push("// PROJECT "+p+" -> "+s),n.push("let proj = {}"),emitFilters2(e,p)(n,o)((()=>{let e=[...s.map(quoteVar)].map((e=>","+e)).join("");n.push("  rt.initTemp(proj"+e+")(() => true)")})),n.push("// TRAVERSE "+s);let r="proj";for(let e of s)isDeepVarStr(e)?(n.push("rt.deepForInTemp("+r+", ("+quoteVar(e)+"_key, "+quoteVar(e)+") => {"),r+="["+quoteVar(e)+"_key]",t="})\n"+t):(n.push("for (let "+quoteVar(e)+" in "+r+") {"),r+="["+quoteVar(e)+"]",t="}\n"+t);i({...e,vars:[...e.vars,...s]}),n.push(t)}},emitFilters2=(e,t)=>(r,n)=>o=>{let i={},s={};if(0==t.length)return o();for(let e of t)i[e]=!0;for(let t of e.vars)s[t]=!0;let p=[];for(let e in filters){let t=filters[e],r=t.arg[1].op;t.arg[0],i[r]&&p.push(e)}let a=[...e.filters],l=[],u=()=>{let e=p;p=[];for(let t of e){let e=filters[t],r=(e.arg[1].op,e.arg[0]),n=r.fre.every((e=>s[e]));settings.extractFilters&&(n&&=subset(r.filters??[],a)),n?l.push(t):p.push(t)}return l.length>0},f="",m=[...e.vars];for(;u();){let t=e=>filters[e].arg[0].fre.length;l.sort(((e,r)=>t(r)-t(e)));let o=l.shift();a.push(o);let p=filters[o],u=p.arg[1].op,y=p.arg[0],d={...e,vars:y.fre,filters:a},c={...e,vars:p.fre,filters:a};console.assert(subset(y.fre,m)),m.push(u);let g=y.fre.filter((e=>!i[e]));0!=g.length&&console.error("extra dependency: "+g),isDeepVarStr(u)?(s[u]?r.push("rt.deepIfIn("+n(y,d)+", "+quoteVar(u)+", () => {"):r.push("rt.deepForIn("+n(y,d)+", "+quoteVar(u)+" => {"),r.push("let gen"+o+" = "+n(p,c)),s[u]=!0,f="})\n"+f):(s[u]?r.push("if ("+quoteVar(u)+" in ("+n(y,d)+"??[])) {"):r.push("for (let ["+quoteVar(u)+", gen"+o+"] of Object.entries("+n(y,d)+"??{})) {"),s[u]=!0,f="}\n"+f)}if(p.length>0){let e=p.map((e=>pretty(filters[e]))).join(", ");console.warn("unsolved filter ordering problem: couldn't emit "+e);for(let e of p)r.push("// ERROR: unsolved filter ordering problem: "+e+" := "+pretty(filters[e]))}o({...e,vars:[...e.vars,...t],filters:[...a]}),r.push(f)},emitStmInline=(e,t)=>{let r=t.buf;"stmCount"in t||(t.stmCount=[0]);let n,o=t.stmCount[0]++;return n="update"==e.key?diff(e.arg[1].vars,t.vars):diff(e.arg[0].dims,t.vars),r.push("/* --- begin "+e.key+"_"+o+" --- "+pretty(e)+" ---*/"),r.push("// env: "+t.vars+" dims: "+e.dims+" bound: "+n),same(n,e.bnd)||(r.push("// WARNING! q.bound "+e.bnd),console.warn("// WARNING! bound "+n+" -> q.bnd "+e.bnd)),n=e.bnd,intersect(n,t.vars).length>0&&(r.push("// WARNING: var '"+n+"' already defined in "+t.vars),console.warn("// WARNING: var '"+n+"' already defined in "+t.vars)),"stateful"==e.key&&e.op+"_init"in runtime.stateful||"update"==e.key?r.push("let tmp"+o+" = "+emitStmInit(e,t)+"()"):r.push("let tmp"+o),emitFilters1(t,e.fre,n)(r,codegen)((t=>{r.push("tmp"+o+" = "+emitStmUpdate(e,t)+".next(tmp"+o+")")})),r.push("/* --- end "+e.key+"_"+o+" */"),"tmp"+o},emitCode=(e,t)=>{let r=[];if(r.push("(inp => {"),r.push("let tmp = {}"),settings.extractAssignments){for(let e of t){e.length>1&&console.error("cycle "+e);let[t]=e,n=assignments[t];r.push("// --- tmp"+t+" ---");let o={vars:[],filters:[],buf:r};("stateful"==n.key&&n.op+"_init"in runtime.stateful||"update"==n.key)&&emitFilters1(o,n.fre,[])(r,codegen)((e=>{let o=[t,...n.fre.map(quoteVar)].map((e=>","+e)).join("");r.push("  rt.init(tmp"+o+")\n  ("+emitStmInit(n,e)+")")})),emitFilters1(o,n.fre,n.bnd)(r,codegen)((e=>{let o=[t,...n.fre.map(quoteVar)].map((e=>","+e)).join("");r.push("  rt.update(tmp"+o+")\n  ("+emitStmUpdate(n,e)+")")})),r.push("")}r.push("// --- res ---")}console.assert(same(e.fre,[]));let n={vars:[],filters:[],buf:r};return r.push("return "+codegen(e,n)),r.push("})"),r.join("\n")},quoteIndexVarsXS_C=(e,t)=>{let r=e;for(let e of t)r="rt_get("+r+", "+quoteVarXS(e)+")";return r},codegenC=e=>{if("input"==e.key)return"inp";if("const"==e.key)return"number"==typeof e.op?Number.isInteger(e.op)?"rt_const_int("+e.op+")":"rt_const_float("+e.op+")":"string"==typeof e.op?'rt_const_string("'+e.op+'")':"object"==typeof e.op&&0==Object.keys(e.op).length?"rt_const_obj()":(console.error("unsupported constant ",pretty(e)),String(e.op));if("var"==e.key)return quoteVar(e.op);if("ref"==e.key){let t=assignments[e.op],r=["rt_const_int("+e.op+")",...t.fre];return quoteIndexVarsXS_C("tmp",r)}if("get"==e.key&&isDeepVarExp(e.arg[1])){let[t,r]=e.arg.map(codegenC);return"rt_deepGet("+t+","+r+")"}if("get"==e.key){let[t,r]=e.arg.map(codegenC);return"rt_get("+t+","+r+")"}if("pure"==e.key){let t=e.arg.map(codegenC);return"rt_pure_"+e.op+"("+t.join(",")+")"}if("hint"==e.key)return"rt_const_int(1)";if("mkset"==e.key){let[t]=e.arg.map(codegenC);return"rt_singleton("+t+")"}return console.error("unknown op ",pretty(e)),"<?"+e.key+"?>"},emitCodeC=(e,t)=>{let r=[];r.push("#include <stdio.h>"),r.push('#include "rhyme.h"'),r.push("int main() {"),r.push("rh inp = 0; // input?"),r.push("rh tmp = rt_const_obj();");for(let e of t){e.length>1&&console.error("cycle "+e);let[t]=e;assignments[t],r.push("// --- tmp"+t+" ---"),r.push("// XXX NOT IMPLEMENTED")}return r.push("// --- res ---"),r.push("rh res = "+codegenC(e)+";"),r.push("write_result(res);"),r.push("}\n"),r.join("\n")},nameEnv={},quoteCppOp=e=>"plus"==e?"+":"minus"==e?"-":"times"==e?"*":"and"==e?"&&":void console.error("Unsupported Op"),quoteGet=(e,t)=>e+"["+t+"]",quoteGets=(e,t)=>{let r=e;for(let e of t)r=quoteGet(r,e);return r},tmpSym=e=>"tmp"+e,quoteStateful=e=>"stateful_"+e,quoteExpr=e=>{if("stateful"==e.key){let t=e.arg.map(quoteExpr).filter((e=>"hint"!=e));return quoteStateful(e.op)+"("+t.join(",")+")"}if("update"!=e.key){if("input"==e.key)return"inp";if("const"==e.key)return"number"==typeof e.op?`${e.op}`:"string"==typeof e.op?quoteStr(e.op):"object"==typeof e.op&&0==Object.keys(e.op).length?"{}":(console.error("unsupported constant ",pretty(e)),String(e.op));if("var"==e.key)return quoteVar(e.op);if("ref"==e.key){let t=[...assignments[e.op].fre];return quoteGets(tmpSym(e.op),t)}if("get"==e.key){let[t,r]=e.arg.map(quoteExpr);return quoteGet(t,r)}if("pure"==e.key){let t=e.arg.map(quoteExpr).filter((e=>"hint"!=e));return 0==t.length?"hint":1==t.length?t[0]:e.op+"("+t.join(",")+")"}if("hint"==e.key)return"hint";if("mkset"==e.key){let[t]=e.arg.map(quoteExpr);return"singleton("+t+")"}return console.error("unknown op ",pretty(e)),"<?"+e.key+"?>"}console.error("unsupported op",pretty(e))},codegenCPP=e=>{let t=e.schema.type,r=quoteExpr(e);if(r in nameEnv)return nameEnv[r];if("input"==e.key)return"inp";if("const"==e.key)return"number"==typeof e.op?String(e.op):"string"==typeof e.op?quoteStr(e.op):"object"==typeof e.op&&0==Object.keys(e.op).length?"rt_const_obj()":(console.error("unsupported constant ",pretty(e)),String(e.op));if("var"==e.key)return quoteVar(e.op);if("ref"==e.key)return r;if("get"==e.key){let[t,r]=e.arg.map(codegenCPP);return t+"["+r+"]"}if("pure"==e.key){let r=e.arg.map(codegenCPP).filter((e=>"hint"!=e));return 0==r.length?"hint":1==r.length?r[0]:typing.isInteger(t)?"("+r.join(" "+quoteCppOp(e.op)+" ")+")":"rt_pure_"+e.op+"("+r.join(",")+")"}return"hint"==e.key?"hint":"mkset"==e.key?(console.error("unhandled op ",pretty(e)),"<?"+e.key+"?>"):(console.error("unknown op ",pretty(e)),"<?"+e.key+"?>")},statefulOpCPP=(e,t=!1)=>{if("sum"==e.op)return t?"+=":"rt_pure_plus";"product"==e.op||"count"==e.op||e.op,console.error("unsupported op",e)},quoteTypeCPP=e=>{if(void 0===e)throw new Error("Unknown undefined type.");if(null===e)throw new Error("Unknown null type.");if(e.typeSym===typeSyms.union)return"rh";if(e.typeSym===typeSyms.tagged_type){if("dense"===e.tag)return"std::vector<"+quoteTypeCPP(typing.removeTag(e).objValue)+">";if("sparse"===e.tag){if(1==e.tagData.dim)return"CSVector<"+quoteTypeCPP(typing.removeTag(e).objValue)+", "+quoteTypeCPP(typing.removeTag(e).objKey)+">";if(2==e.tagData.dim)return"CSRMatrix<"+quoteTypeCPP(typing.removeTag(typing.removeTag(e).objValue).objValue)+", "+quoteTypeCPP(typing.removeTag(e).objKey)+">";throw new Error("Unknown sparse item with data: "+e.tagData)}throw new Error("Unknown tag: "+e.tag)}if(e.typeSym===typeSyms.dynkey)return quoteTypeCPP(e.keySupertype);let t={any:"rh",never:"rh",boolean:"rh",string:"rh",u8:"uint8_t",u16:"uint16_t",u32:"uint32_t",u64:"uint64_t",i8:"int8_t",i16:"int16_t",i32:"int",i64:"int64_t",f32:"float",f64:"double"};if(e.typeSym in t)return t[e.typeSym];if(typing.isObject(e))return"rh";throw new Error("Unknown type: "+JSON.stringify(e))},quoteFileReadCPP=e=>{if(e.typeSym===typeSyms.tagged_type){if("dense"===e.tag){if(1==e.tagData.dim)return"read_1D_dense_tensor<"+quoteTypeCPP(typing.removeTag(e).objValue)+">";if(2==e.tagData.dim)return"read_2D_dense_tensor<"+quoteTypeCPP(typing.removeTag(typing.removeTag(e).objValue).objValue)+">";throw new Error("Unknown dense item with data: "+e.tagData)}if("sparse"===e.tag){if(1==e.tagData.dim)return"read_1D_sparse_tensor<"+quoteTypeCPP(typing.removeTag(e).objValue)+", "+quoteTypeCPP(typing.removeTag(e).objKey)+">";if(2==e.tagData.dim)return"read_2D_sparse_tensor<"+quoteTypeCPP(typing.removeTag(typing.removeTag(e).objValue).objValue)+", "+quoteTypeCPP(typing.removeTag(e).objKey)+">";throw new Error("Unknown sparse item with data: "+e.tagData)}throw new Error("Unknown tag: "+e.tag)}if(typing.isObject(e))return"read_json";throw new Error("Unknown how to read: "+typing.prettyPrintType(e))},emitStmInitCPP=e=>{if("stateful"==e.key){if("sum"==e.op)return"= 0";"product"==e.op||"count"==e.op||e.op,console.error("unsupported op",e)}else"update"==e.key?console.error("unsupported op",e):console.error("unknown op",e)},emitStmUpdateCPP=(e,t)=>{if("prefix"==t.key)console.error("unsupported op",t);else{if("stateful"==t.key){let r=t.schema.type,[n]=t.arg.map(codegenCPP),o="("+quoteTypeCPP(r)+")";return e+" "+statefulOpCPP(t,!0)+" "+o+"("+n+")"}"update"==t.key?console.error("unsupported op",t):console.error("unknown op",t)}},emitCodeCPP=(e,t)=>{let r=[],n=[],o={};nameEnv={};let i=(e,...t)=>({txt:e,deps:t}),s=(e,t,n,s)=>{let p=i(e+";",...n,...s);p.lhs=i("LHS",...n),p.op="=?=",p.rhs=i("RHS",...s),p.writeSym=t,p.deps=p.deps.filter((e=>e!=p.writeSym)),o[p.writeSym]??=1,p.writeRank=o[p.writeSym],o[p.writeSym]+=1,r.push(p)};function p(e,t){let r=a(e),o=r.deps[0];if(1==t.length){let r=t[0],s=a(r),p=i("FOR",...s.deps);p.sym=o,p.rhs=s.txt,p.loopTxt=((e,t)=>{let r=e.schema.type,n=codegenCPP(e),o=codegenCPP(t);if(r.typeSym===typeSyms.tagged_type){if("dense"==r.tag){let e=quoteExpr(t);return`for (int ${e}=0; ${e}<${n}.size(); ${e}++) {`}if("sparse"==r.tag)return`for (const auto& [${o}, ${o}_val] : ${n}) {`}if(typing.isObject(r))return`for (const auto& [${o}, ${o}_val] : ${n}.items()) {`;throw new Error("Unknown loop type: "+typing.prettyPrintType(r))})(r,e),n.push(p)}else{let e=t.map(a),s=t.map((e=>e.schema.type));if(!s.every(typing.isSparseVec))throw new Error("Unsupported container types");let p=e.map((e=>"&"+e.txt)),u=r.txt+"_mit",f="for (auto "+u+" = "+quoteTypeCPP(s[0])+"::multi_iterator({"+p.join(",")+"});!"+u+".finish(); ++"+u+") {";for(l of t){let e=t[0],r=a(e),s=i("FOR",...r.deps);s.sym=o,s.rhs=r.txt,s.loopTxt=f,n.push(s)}}}let a=e=>i(codegenCPP(e),...(e=>[...e.fre,...e.tmps.map(tmpSym)])(e)),u={},f=e=>{if("get"==e.key){let t=quoteExpr(e.arg[0]),r=e.arg[1].op;if("inp"==t&&!(r in u)){let t=quoteExpr(e);return u[r]={expr:t,schema:e.schema},void(nameEnv[t]=r)}}e.arg&&e.arg.forEach(f)},m=(e,t)=>{if(typing.isSparse(e)||typing.isObject(e)&&!typing.isDense(e))return t+"_val"},y=(e,t,r)=>{if(!e.every(typing.isSparseVec))throw new Error("Unsupported container types");return"(*"+t+"_mit).second["+r+"]"},d={};for(let e in filters){let t=filters[e],r=t.arg[1],n=r.op,o=t.arg[0];d[n]??={},d[n].expr=r,d[n].loops??=[],d[n].loops.push(o)}for(let e in d){let t=d[e].loops;t.forEach(f);let r=quoteVar(e);if(1==t.length){let e=t[0],n=quoteExpr(e),o=e.schema.type,i=quoteGet(n,r),s=m(o,r);s&&(nameEnv[i]=s)}else{let e=t.map((e=>e.schema.type));if(!e.every(typing.isSparseVec))throw new Error("Unsupported container types");for(let n in t){let o=t[n],i=quoteExpr(o),s=quoteGet(i,r),p=y(e,r,n);p&&(nameEnv[s]=p)}}}for(let e in assignments){let t=assignments[e];f(t)}f(e);let c=e.schema.type;for(let e in assignments){let t=tmpSym(e),r=assignments[e];if("stateful"==r.key&&r.op+"_init"in runtime.stateful){let e=[...r.fre.map(quoteVar)],n=e.map((e=>'["'+e+'"]')).join("");e.length>0?s(t+n+emitStmInitCPP(r),t,r.fre,[]):s(quoteTypeCPP(r.schema.type)+" "+t+" "+emitStmInitCPP(r),t,r.fre,[])}else"update"==r.key&&console.error("Unsupported Op");{let e=union(r.fre,r.bnd),n=[...r.fre.map(quoteVar)].map((e=>'["'+e+'"]')).join(""),o=[...e,...r.tmps.map(tmpSym)];s(emitStmUpdateCPP(t+n,r),t,r.fre,o)}}for(let e in d)p(d[e].expr,d[e].loops);let g=a(e),h=[];h.push('#include "rhyme.hpp"'),h.push("int main() {");for(let e in u){let t=u[e].schema.type;h.push(`${quoteTypeCPP(t)} ${e} = ${quoteFileReadCPP(t)}("cgen/${e}.json");`)}let x=[];return x.push(quoteTypeCPP(c)+" res = "+g.txt+";"),x.push("write_result(res);"),x.push("}"),generate({assignmentStms:r,generatorStms:n,tmpVarWriteRank:o,res:g,prolog:h,epilog:x},"cpp")},fixIndent=e=>{let t=e.split("\n"),r=[],n=0;for(let e of t){if(""==e.trim())continue;let t=t=>(e.match(t)??[]).length,o=t(/{/g)-t(/}/g);"}"==e[0]&&(n+=o),r.push("".padEnd(4*n," ")+e.trim()),"}"!=e[0]&&(n+=o)}return r.join("\n")},translateToNewCodegen=e=>{let t=[],r=[],n={},o=(e,...t)=>({txt:e,deps:t}),i=(e,r,i,s)=>{let p=o(e,...i,...s);p.lhs=o("LHS",...i),p.op="=?=",p.rhs=o("RHS",...s),p.writeSym=r,p.deps=p.deps.filter((e=>e!=p.writeSym)),n[p.writeSym]??=1,p.writeRank=n[p.writeSym],n[p.writeSym]+=1,t.push(p)};function s(e,t){let n=t.deps[0],i=o("FOR",...e.deps);i.sym=n,i.rhs=e.txt,r.push(i)}let p=e=>"tmp-"+e,a=(e,t)=>o(codegen(e,t),...(e=>[...e.fre,...e.tmps.map(p)])(e));for(let e in assignments){let t=p(e),r=assignments[e];if("stateful"==r.key&&r.op+"_init"in runtime.stateful||"update"==r.key){let n=[e,...r.fre.map(quoteVar)].map((e=>","+e)).join(""),o=[];if("update"==r.key){let e=r.arg[0];o=[...union(e.fre,e.bnd),...e.tmps.map(p)]}let s={vars:r.fre,filters:[],buf:[]};i("rt.init(tmp"+n+")("+emitStmInit(r,s)+")",t,r.fre,o)}{let n=union(r.fre,r.bnd),o=[e,...r.fre.map(quoteVar)].map((e=>","+e)).join(""),s=[...n,...r.tmps.map(p)],a={vars:r.fre,filters:[],buf:[]};i("rt.update(tmp"+o+")("+emitStmUpdate(r,a)+")",t,r.fre,s)}}for(let e in filters){let t=filters[e],r={vars:t.fre,filters:[]},[n,o]=t.arg.map((e=>a(e,r)));s(n,o)}let l={vars:e.fre,filters:[]},u=a(e,l);return generate({assignmentStms:t,generatorStms:r,tmpVarWriteRank:n,res:u})},compile=(q,userSettings={})=>{reset(userSettings);let trace={log:()=>{}};q=preproc(q);let src=q;if(settings.altInfer){trace.log(q);let e=JSON.parse(JSON.stringify(q)),t=deno(e)((e=>{let t={out:e.dims};return trace.log("K:",e,"->",t),t}));trace.log("RES:",t)}q=extract0(q),settings.antiSubstGroupKey&&!settings.newCodegen&&(q=extract0b(q,[])),q=inferDims(q),extract1(q),computeDependencies();let out=settings.singleResult?q.mind:q.dims;for(q=inferBound(out)(q),varsChanged=!1,extract1f(q),computeDependenciesf(),q=inferFree(out)(q);varsChanged=!1,extract1f(q),varsChanged;)computeDependenciesf(),q=inferFree(out)(q);out.length>0&&(q={key:"update",arg:[{key:"const",op:{},arg:[],vars:[],mind:[],dims:[],bnd:[],fre:[]},{key:"pure",op:"vars",arg:out.map((e=>({key:"var",op:e,arg:[],vars:[e],mind:[e],dims:[e]}))),vars:out,mind:out,dims:out,bnd:[],fre:[]},q],vars:q.vars,mind:[],dims:[],bnd:out,fre:[]}),typing.validateIR(settings.schema,q),settings.extractAssignments&&(q=extract2(q));for(let e of assignments)extract3(e);extract3(q);let order=computeOrder(q),pseudo=emitPseudo(q);if(settings.newCodegen)return translateToNewCodegen(q);if("c"==settings.backend||"cpp"==settings.backend){const e=__webpack_require__(840),t=__webpack_require__(994);let r=function(e){return new Promise((function(r,n){t.exec(e,(function(e,t){if(e)return n(e);r(t)}))}))},n,o,i,s;"c"==settings.backend?(n=fixIndent(emitCodeC(q,order)),o="gcc",i="test.c",s=""):(n=emitCodeCPP(q,order),o="g++",i="test.cpp",s="-std=c++17 -Ithirdparty/json/include");let p=(async()=>(await e.writeFile(`cgen/${i}`,n),await r(`${o}  ${s} cgen/${i} -o cgen/test.out`),"cgen/test.out"))(),a=async t=>{let n=await p;for(let r in t)await e.writeFile(`cgen/${r}.json`,JSON.stringify(t[r]));return await r(n)};return a.explain={src,ir:{filters,assignments,vars,order},pseudo,code:n},a}if("c-sql"==settings.backend){let e={filters,assignments,vars,order};return generateCSql(q,e)}if("c-sql-new"==settings.backend){let e={filters,assignments,vars,order};return generateCSqlNew(q,e,settings.outDir,settings.outFile)}let code=emitCode(q,order);code=fixIndent(code),trace.log(pseudo),trace.log(code);let rt=runtime,func=eval(code),wrap=e=>func(e);return wrap.explain={src,resultType:q.schema,ir:{filters,assignments,vars,order},pseudo,code},wrap},compilePrimitive=(q,userSettings={})=>{reset(userSettings),settings.extractAssignments=!1,settings.extractFilters=!1;let trace={log:()=>{}};q=preproc(q);let src=q;q=extract0(q),q=inferDims(q),extract1(q),computeDependencies();let out=settings.singleResult?q.mind:q.dims;for(q=inferBound(out)(q),varsChanged=!1,extract1f(q),computeDependenciesf(),q=inferFree(out)(q);varsChanged=!1,extract1f(q),varsChanged;)computeDependenciesf(),q=inferFree(out)(q);out.length>0&&(q={key:"update",arg:[{key:"const",op:{},arg:[],vars:[],dims:[]},{key:"pure",op:"vars",arg:out.map((e=>({key:"var",op:e,arg:[]}))),vars:out,dims:out},q],vars:q.vars,dims:[],bnd:out,fre:[]}),extract3(q);let pseudo=emitPseudo(q),code=emitCode(q);code=fixIndent(code),trace.log(pseudo),trace.log(code);let rt=runtime,func=eval(code),wrap=e=>func(e);return wrap.explain={src,ir:{filters},pseudo,code},wrap};exports.compile=compile,exports.compilePrimitive=compilePrimitive},696:(e,t)=>{let r=t.runtime={};r.special={},r.pure={},r.stateful={},r.special.get=!0,r.special.group=!0,r.special.update=!0,r.special.update_inplace=!0,r.special.merge=r.special.keyval=!0,r.pure.equal=(e,t)=>{if(void 0!==e&&void 0!==t)return e===t},r.pure.notEqual=(e,t)=>{if(void 0!==e&&void 0!==t)return e!==t},r.pure.plus=(e,t)=>{if(void 0===e)return;if(void 0===t)return;let r=Number(e)+Number(t);return Number.isNaN(r)?e+t:r},r.pure.minus=(e,t)=>{if(void 0!==e&&void 0!==t)return Number(e)-Number(t)},r.pure.times=(e,t)=>{if(void 0!==e&&void 0!==t)return Number(e)*Number(t)},r.pure.fdiv=(e,t)=>{if(void 0!==e&&void 0!==t)return Number(e)/Number(t)},r.pure.div=(e,t)=>{if(void 0!==e&&void 0!==t)return Math.trunc(Number(e)/Number(t))},r.pure.mod=(e,t)=>{if(void 0!==e&&void 0!==t)return Number(e)%Number(t)},r.pure.apply=(e,...t)=>{if(void 0!==e)return e(...t)},r.pure.join=e=>{if(void 0!==e)return e.join()},r.pure.flatten=(...e)=>{if(void 0!==e)return e.flat()},r.pure.and=(e,t)=>{if(void 0!==e)return t},r.pure.singleton=e=>void 0===e?{}:{[e]:!0},r.singleton=e=>void 0===e?{}:{[e]:!0},r.stateful.sum_init=()=>0,r.stateful.sum=e=>({init:()=>0,next:t=>void 0===e||Number.isNaN(Number(e))?t:void 0===t||Number.isNaN(Number(t))?e:t+e}),r.stateful.product_init=()=>1,r.stateful.product=e=>({init:()=>1,next:t=>void 0===e?t:void 0===t?e:t*e}),r.stateful.count_init=()=>0,r.stateful.count=e=>({init:()=>0,next:t=>void 0===e?t:void 0===t?1:t+1}),r.stateful.min=e=>({init:()=>{},next:t=>void 0===e?t:void 0===t?e:t<=e?t:e}),r.stateful.max=e=>({init:()=>{},next:t=>void 0===e?t:void 0===t?e:t>=e?t:e}),r.stateful.all_init=()=>!0,r.stateful.all=e=>({init:()=>!0,next:t=>{if(void 0!==e&&void 0!==t)return t}}),r.stateful.any=e=>({init:()=>{},next:t=>void 0===e?t:void 0===t?e:t}),r.stateful.first=e=>({init:()=>{},next:t=>void 0===e?t:void 0===t?e:t}),r.stateful.last=e=>({init:()=>{},next:t=>void 0===e?t:e}),r.stateful.single=e=>({init:()=>{},next:t=>void 0===e?t:void 0===t?e:(JSON.stringify(t)!==JSON.stringify(e)&&console.error("single value expected but got two: "+t+", "+e),t)}),r.stateful.array_init=()=>[],r.stateful.array=e=>({init:()=>[],next:t=>(void 0===e||t.push(e),t)}),r.stateful.mkset_init=()=>({}),r.stateful.mkset=e=>({init:()=>({}),next:t=>(void 0===e||(t[e]=!0),t)}),r.stateful.prefix=e=>({init:()=>[],next:t=>(t&&t.length?t.push(e.next(t[t.length-1])):t=[e.next(e.init())],t)}),r.stateful.group=(e,t)=>({init:()=>({}),next:r=>(void 0===e||void 0===t||(void 0===r&&(r={}),r[e]=t),r)}),r.uniqueMutableCopy=e=>({...e}),r.stateful.update_init=e=>()=>r.uniqueMutableCopy(e),r.stateful.update=(e,t,n)=>({init:()=>({...e}),next:o=>(void 0===t||void 0===n||(void 0===o&&(o="object"==typeof e?r.uniqueMutableCopy(e):e),t instanceof Array?o=r.deepUpdate(o,t,n):(console.assert("object"==typeof o),o[t]=n)),o)}),r.update=(e,...t)=>r=>{let n=e;for(let e of t.slice(0,t.length-1)){if(void 0===e)return;e instanceof Array&&console.error("TODO: add deep update! ",t),n[e]??={},n=n[e]}let o=t[t.length-1];if(o instanceof Array){o=o.join("-")+"-";let e=r.init();"number"==typeof e&&(n[o]??=e),n[o]=r.next(n[o])}else n[o]=r.next(n[o])},r.init=(e,...t)=>n=>{let o=e;for(let e of t.slice(0,t.length-1)){if(void 0===e)return;e instanceof Array&&console.error("TODO: add deep init! ",t),o[e]??={},o=o[e]}let i=t[t.length-1];i instanceof Array?void 0===r.deepGet(o,i)&&r.deepUpdate(o,i,n()):o[i]??=n()},r.deepGet=(e,t)=>{if(t instanceof Array){if(t.length>0){let[n,...o]=t;return n instanceof Array&&console.error("TODO: two-level nesting: ",t),r.deepGet(e?.[n],o)}return e}return e?.[t]},r.deepUpdate=(e,t,n)=>{if(void 0===n)return e;if(t.length>0){let[o,...i]=t;return o instanceof Array?e=r.deepUpdate(e,[...o,...i],n):(e??={},e[o]=r.deepUpdate(e[o]??{},i,n)),e}return n},r.deepForIn=(e,t)=>{if(t([]),"object"==typeof e)for(let n in e)r.deepForIn(e[n],(e=>{t([n,...e])}))},r.deepIfIn=(e,t,n)=>{if(t instanceof Array)if(t.length>0){let[o,...i]=t;o instanceof Array&&console.error("TODO: two-level nesting: ",t),e&&o in e&&r.deepIfIn(e[o],i,n)}else n();else e&&t in e&&n()},r.encodeTemp=e=>e instanceof Array?JSON.stringify(e):e,r.decodeTemp=e=>e.startsWith("[")?JSON.parse(e):e,r.initTemp=(e,...t)=>n=>{let o=e;for(let e of t.slice(0,t.length-1))e=r.encodeTemp(e),o[e]??={},o=o[e];let i=t[t.length-1];i=r.encodeTemp(i),o[i]??=n()},r.deepForInTemp=(e,t)=>{for(let n in e)t(n,r.decodeTemp(n))},r.globalVarDomain=[0,1,2,3,4,5,6,7,8,9,10,20,30,40,50,60,"0","1","2","3","4","5","6","7","8","9","20","40","A","B","C","D","E","F","G","H","U","V","W","X","Y","Z","total","all","items","foo","bar","iPhone","Galaxy","S6","7","Q","region","Asia","Europe","Osaka","Hamburg","Shanghai","seeds","lengthX","startX","fib"]},551:(e,t,r)=>{const{runtime:n}=r(696),{typing:o,types:i}=r(104);let s,p=(e,t)=>{return(r=[...e,...t]).filter(((e,t)=>r.indexOf(e)==t));var r},a=(e,t)=>{let r={},n=[];for(let e of t)r[e]=!0;for(let t of e)r[t]||n.push(t);return n},l=(e,t)=>{let r={};for(let e of t)r[e]=!0;for(let t of e)if(!r[t])return!1;return!0},u={u8:"uint8_t",u16:"uint16_t",u32:"uint32_t",u64:"uint64_t",i8:"int8_t",i16:"int16_t",i32:"int32_t",i64:"int64_t",f32:"float",f64:"double"},f={u8:"hhu",u16:"hu",u32:"u",u64:"lu",i8:"hhd",i16:"hd",i32:"d",i64:"ld",f32:".3f",f64:".3lf"},m=e=>{if("dynkey"===e.typeSym)return m(e.keySuperkey);if("union"===e.typeSym)throw new Error("Unable to convert union type to C type currently: "+o.prettyPrintType(e));if(e.typeSym in u)return u[e.typeSym];throw new Error("Unknown type: "+o.prettyPrintType(e))},y=e=>{if("dynkey"===e.typeSym)return y(e.keySuperkey);if("union"===e.typeSym)throw new Error("Unable to get type specifier for union tpyes currently: "+o.prettyPrintType(e));if(e.typeSym in f)return f[e.typeSym];throw new Error("Unknown type: "+o.prettyPrintType(e))},d=(e,t)=>{let{buf:r,getNewName:n,fileColumnPos:i,file:p}=t;if("input"==e.key)return"not supported";if("loadInput"==e.key){if("csv"==e.op){t.file=e.arg[0].op;let{mappedFile:r}=s[t.file];return r}return"not supported"}if("const"==e.key){if("string"==typeof e.op){let t=n(e.op),{start:a,end:l}=i[p][e.op],{mappedFile:u}=s[p];if(o.isInteger(e.schema.type)){r.push(`// extracting number from column ${e.op} in file ${p}`),r.push(`${m(e.schema.type)} ${t} = 0;`);let o=n("curr");r.push(`int ${o} = ${a};`),r.push(`while (${o} < ${l}) {`),r.push(`${t} *= 10;`),r.push(`${t} += (${u}[${o}] - '0');`),r.push(`${o}++;`),r.push("}")}return t}return"number"==typeof e.op?e.op:(console.error("unsupported constant ",pretty(e)),String(e.op))}if("var"==e.key)return e.op.replaceAll("*","x");if("ref"==e.key)return`tmp${e.op}`;if("get"==e.key){let r=d(e.arg[0],t);return"loadInput"==e.arg[0].key&&"var"==e.arg[1].key?r+"_"+d(e.arg[1],t):"get"==e.arg[0].key&&"const"==e.arg[1].key?(e.arg[1].schema=e.schema,d(e.arg[1],t)):(console.error("malformed get"),"malformed get")}if("pure"==e.key){let r=e.arg.map((e=>d(e,t)));return`${r[0]} + ${r[1]}`}return"hint"==e.key||"mkset"==e.key||"stateful"==e.key||"prefix"==e.key||"update"==e.key?"not supported":(console.error("unknown op",pretty(e)),"<?"+e.key+"?>")},c=(e,t)=>{if("stateful"==e.key){if("sum"==e.op||"count"==e.op)return`${m(e.schema.type)} ${t} = 0;`;if("product"==e.op)return`${m(e.schema.type)} ${t} = 1;`;if("min"==e.op)return`${m(e.schema.type)} ${t} = INT_MAX;`;if("max"==e.op)return`${m(e.schema.type)} ${t} = INT_MIN;`}else{if("update"==e.key)return"not supported";console.error("unknown op",e)}},g=(e,t,r)=>{if("prefix"==e.key)return"not supported";if("stateful"==e.key){let[n]=e.arg.map((e=>d(e,t)));if("sum"==e.op)return`${r} += ${n};`;if("product"==e.op)return`${r} *= ${n};`;if("min"==e.op)return`${r} = ${n} < ${r} ? ${n} : ${r};`;if("max"==e.op)return`${r} = ${n} > ${r} ? ${n} : ${r};`;if("count"==e.op)return`${r} += 1;`;if("print"==e.op)return`printf("%${y(e.arg[0].schema.type)}\\n", ${n});`}else{if("update"==e.key)return"not supported";console.error("unknown op",e)}},h=(e,t)=>{let{loadCSVBuf:r,getNewName:n}=t;r.push(`// loadCSV ${e}`);let o=n("fd"),i=n("csv"),p=n("n");r.push(`int ${o} = open("${e}", 0);`),r.push(`if (${o} == -1) {`),r.push(`fprintf(stderr, "Unable to open file ${e}\\n");`),r.push("return 1;"),r.push("}"),r.push(`int ${p} = fsize(${o});`),r.push(`char *${i} = mmap(0, ${p}, PROT_READ, MAP_FILE | MAP_SHARED, ${o}, 0);`),r.push(`close(${o});`),s[e]={fd:o,mappedFile:i,size:p}},x=(e,t,r)=>{let{buf:n}=r,{mappedFile:o,size:i}=e;n.push(`int ${t} = 0;`),n.push(`while (${o}[${t}] != '\\n') {`),n.push(`${t}++;`),n.push("}"),n.push("while (1) {"),n.push(`if (${t} >= ${i}) break;`)},k=(e,t,r,n,o=!0)=>{if(null==r.objKey)return{};let i=k(e,t,r.objParent,n,!1),{buf:s,getNewName:p}=n,{mappedFile:a}=e;s.push(`// reading column ${r.objKey}`);let l=o?"\\n":",",u=p("start"),f=p("end");return s.push(`int ${u} = ${t};`),s.push("while (1) {"),s.push(`char c = ${a}[${t}];`),s.push(`if (c == '${l}') break;`),s.push(`${t}++;`),s.push("}"),s.push(`int ${f} = ${t};`),s.push(`${t}++;`),i[r.objKey]={start:u,end:f},i},v=(e,t,r)=>(n,o)=>i=>{let s=a(p(t,r),e.vars);if(0==s.length)return i(e);let u=p(t,r);var f,m;f=a(u,e.vars),l(f,m=s)&&l(m,f)?b(e,u)(n,o)(i):console.error("We don't do this for now")},b=(e,t)=>(r,n)=>n=>{let o=e.ir.filters,i=e.loadCSVBuf,p=e.getNewName,a={},u={};if(0==t.length)return n();for(let e of t)a[e]=!0;for(let t of e.vars)u[t]=!0;let f=[];for(let e in o){let t=o[e],r=t.arg[1].op;t.arg[0],a[r]&&f.push(e)}let m=[...e.filters],y=[],d=()=>{let e=f;f=[];for(let t of e){let e=o[t],r=(e.arg[1].op,e.arg[0]),n=r.fre.every((e=>u[e]));n&&=l(r.filters??[],m),n?y.push(t):f.push(t)}return y.length>0},c="",g={},v={};for(;d();){let t=e=>o[e].arg[0].fre.length;y.sort(((e,r)=>t(r)-t(e)));let n=y.shift();m.push(n);let l=o[n],f=l.arg[1].op,d=l.arg[0],b=l.schema;if("loadInput"!=d.key||"csv"!=d.op)return void console.error("invalid filter");if("const"!=d.arg[0].key||"string"!=typeof d.arg[0].op)return void console.error("expected filename to be constant string for c-sql backend");let S=d.fre.filter((e=>!a[e]));if(0!=S.length&&console.error("extra dependency: "+S),f.startsWith("**"))r.push("deep var not supported");else{let t=d.arg[0].op;void 0===s[t]&&h(t,e);let n=s[t];r.push(`// filter ${f} <- ${t}`);let o=p("i");if(g[t]=o,u[f]){i.push(`int ${o} = 0;`),i.push(`while (${n.mappedFile}[${o}] != '\\n') {`),i.push(`${o}++;`),i.push("}"),r.push(`if (${o} >= ${n.size}) break;`);let s=k(n,o,b.type,e);v[t]=s}else{x(n,o,e);let r=k(n,o,b.type,e);v[t]=r,c="}\n"+c}u[f]=!0}}if(f.length>0){let e=f.map((e=>pretty(o[e]))).join(", ");console.warn("unsolved filter ordering problem: couldn't emit "+e);for(let e of f)r.push("// ERROR: unsolved filter ordering problem: "+e+" := "+pretty(o[e]))}n({...e,vars:[...e.vars,...t],filters:[...m],fileColumnPos:v}),r.push(c)},S={sum:!0,prodcut:!0,min:!0,max:!0,count:!0,print:!0};t.generateCSql=(e,t)=>{const n=r(840),o=r(994);let p=function(e){return new Promise((function(t,r){o.exec(e,(function(e,n){e&&r(e),t(n)}))}))},a=(e=>{let t=e.split("\n"),r=[],n=0;for(let e of t){if(""==e.trim())continue;let t=t=>(e.match(t)??[]).length,o=t(/{/g)-t(/}/g);"}"==e[0]&&(n+=o),r.push("".padEnd(4*n," ")+e.trim()),"}"!=e[0]&&(n+=o)}return r.join("\n")})(((e,t)=>{s={},filters=t.filters;let{assignments:r,order:n}=t,o=[],p=[],a={},l=e=>{a[e]??=0;let t=e+a[e];return a[e]+=1,t};for(let e of n){e.length>1&&console.error("cycle "+e);let[n]=e,i=r[n];o.push("// --- tmp"+n+" ---"),"stateful"==i.key&&S[i.op]&&o.push(c(i,`tmp${n}`)),v({buf:o,loadCSVBuf:p,ir:t,getNewName:l,vars:[],filters:[]},i.fre,i.bnd)(o,d)((e=>{o.push(g(i,e,`tmp${n}`))}))}return e.schema.type!=i.never&&(o.push(`${m(e.schema.type)} res = ${d(e,{buf:o,ir:t,getNewName:l})};`),o.push(`printf("%${y(e.schema.type)}\\n", res);`)),p.push(""),"#include <stdio.h>\n#include <fcntl.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <limits.h>\n#include <stdint.h>\n\nint fsize(int fd) {\nstruct stat stat;\nint res = fstat(fd,&stat);\nreturn stat.st_size;\n}\n\nint main() {\n"+p.join("\n")+o.join("\n")+"return 0;\n}\n"})(e,t)),l=(async()=>(await n.writeFile("out/sql.c",a),await p("gcc out/sql.c -o out/sql"),"out/sql"))(),u=async e=>{let t=await l;return await p(`${t}`)};return u.explain={ir:t,code:a},u}},479:(e,t,r)=>{const{generate:n}=r(621),{typing:o,typeSyms:i}=r(104);let s,p,a,l,u,f,m=(e,t)=>{return(r=[...e,...t]).filter(((e,t)=>r.indexOf(e)==t));var r},y=e=>"tmp"+e,d=e=>e.replaceAll("*","x"),c={},g=e=>{c[e]??=0;let t=e+c[e];return c[e]+=1,t},h={sum:!0,prodcut:!0,min:!0,max:!0,count:!0},x={u8:"uint8_t",u16:"uint16_t",u32:"uint32_t",u64:"uint64_t",i8:"int8_t",i16:"int16_t",i32:"int32_t",i64:"int64_t",f32:"float",f64:"double"},k={u8:"hhu",u16:"hu",u32:"u",u64:"lu",i8:"hhd",i16:"hd",i32:"d",i64:"ld",f32:".3f",f64:".3lf"},v=e=>{if("dynkey"===e.typeSym)return v(e.keySuperkey);if("union"===e.typeSym)throw new Error("Unable to convert union type to C type currently: "+o.prettyPrintType(e));if(e.typeSym in x)return x[e.typeSym];throw new Error("Unknown type: "+o.prettyPrintType(e))},b=e=>{if("dynkey"===e.typeSym)return b(e.keySuperkey);if("union"===e.typeSym)throw new Error("Unable to get type specifier for union tpyes currently: "+o.prettyPrintType(e));if(e.typeSym in k)return k[e.typeSym];throw new Error("Unknown type: "+o.prettyPrintType(e))},S=e=>{if("input"==e.key)return"inp";if("loadInput"==e.key){let[t]=e.arg.map(S);return`loadCSV(${t})`}if("const"==e.key)return"object"==typeof e.op&&0==Object.keys(e.op).length?"{}":""+e.op;if("var"==e.key)return e.op;if("ref"==e.key){let r=p[e.op];return"tmp"+e.op+(void 0===(t=r.fre)?"[?]":"["+t.map((e=>"string"==typeof e?e:S(e))).join(",")+"]")}if("get"==e.key){let[t,r]=e.arg.map(S);return"inp"==t?r:t+"["+r+"]"}if("pure"==e.key){let t=e.arg.map(S);return e.op+"("+t.join(", ")+")"}if("hint"==e.key){let t=e.arg.map(S);return e.op+"("+t.join(", ")+")"}if("mkset"==e.key){let[t]=e.arg.map(S);return"mkset("+t+")"}if("prefix"==e.key){let[t]=e.arg.map(S);return"prefix_"+e.op+"("+t+")"}if("stateful"==e.key){let[t]=e.arg.map(S);return e.op+"("+t+")"}if("group"==e.key){let[t,r]=e.arg.map(S);return"{ "+t+": "+r+" }"}if("update"==e.key){let[t,r,n,o]=e.arg.map(S);return o?t+"{ "+r+": "+n+" } / "+o:t+"{ "+r+": "+n+" }"}var t;console.error("unknown op",e)},$={equal:"==",notEqual:"!=",plus:"+",minus:"-",times:"*",fdiv:"/",div:"/",mod:"%"},w=(e,t=!1)=>{if("get"==e.key){let[r,n]=e.arg;if("get"!=r.key||"const"!=n.key)throw new Error("malformed get: "+S(e));if("loadInput"!=r.arg[0].key||"var"!=r.arg[1].key)throw new Error("malformed e1 in get: "+S(r));if("string"!=typeof n.op)throw new Error("column name is not a constant string: "+S(n));let i=S(r);if(l[i]??={},o.isInteger(e.schema.type))l[i][n.op]=!0;else{if(!o.isString(e.schema.type))throw new Error("column data type not supported: "+S(e)+" has type "+o.prettyPrintTuple(e.schema));t&&(l[i][n.op]=!0)}w(r.arg[0].arg[0],!0)}else if("ref"==e.key){let t=p[e.op];w(t)}else if("update"==e.key){if(null==e.arg[3])throw new Error("trivial group op not supported for now: "+S(e));let[t,r,n,i]=e.arg;if(!o.isString(i.arg[0].arg[0].schema.type)&&!o.isInteger(i.arg[0].arg[0].schema.type))throw new Error(`value of type ${o.prettyPrintTuple(i.arg[0].arg[0].schema)} not allowed for mkset`);w(n),w(i.arg[0].arg[0])}else e.arg&&e.arg.map((e=>w(e)))},_=(e,t,r,n=!0)=>{e.push(`// loadCSV ${t}`);let o="fd"+r,i="csv"+r,s="n"+r;n?e.push(`int ${o} = open("${t}", 0);`):e.push(`int ${o} = open(${t}, 0);`),e.push(`if (${o} == -1) {`),n?e.push(`fprintf(stderr, "Unable to open file ${t}\\n");`):e.push(`fprintf(stderr, "Unable to open file ${t}: %s\\n", ${t});`),e.push("return 1;"),e.push("}"),e.push(`int ${s} = fsize(${o});`),e.push(`char *${i} = mmap(0, ${s}, PROT_READ, MAP_FILE | MAP_SHARED, ${o}, 0);`),e.push(`close(${o});`),a[t]={mappedFile:i,size:s}},q=(e,t,r=!1)=>{if("loadInput"==e.key)throw new Error("cannot have stand-alone loadInput");if("const"==e.key){if("number"==typeof e.op)return String(e.op);if("string"==typeof e.op){let n=g("tmp_str");return t.push(`char ${n}[${e.op.length+1}] = "${e.op}";`),r?n:{file:n,start:"0",end:e.op.length}}throw new Error("constant not supported: "+S(e))}if("var"==e.key)throw new Error("cannot have stand-alone var");if("ref"==e.key){let r=p[e.op];if(r.fre.length>0){let n=y(e.op),i=j(t,n,r.fre[0])[1],{valSchema:s}=f[n];return o.isString(s)?{file:`${n}_values_str[${i}]`,start:"0",end:`${n}_values_len[${i}]`}:`${n}_values[${i}]`}return y(e.op)}if("get"==e.key){let t,[n,i]=e.arg,s=n.arg[0].arg[0];t="const"==s.key&&"string"==typeof s.op?s.op:q(s,[],!0);let{mappedFile:p}=a[t],l=n.arg[1].op,u=[p,d(l),i.op,"start"].join("_"),f=[p,d(l),i.op,"end"].join("_"),m=[p,d(l),i.op].join("_");if(o.isInteger(e.schema.type))return m;if(o.isString(e.schema.type))return r?m:{file:p,start:u,end:f};throw new Error("cannot extract value of type "+o.prettyPrintTuple(e.schema))}if("pure"!=e.key)throw new Error("unknown op: "+S(e));{let r=q(e.arg[0],t),n=$[e.op];if("plus"==e.op||"minus"==e.op||"times"==e.op||"fdiv"==e.op||"div"==e.op||"mod"==e.op){let o=q(e.arg[1],t);return"fdiv"==e.op?`(double)${r} ${n} (double)${o}`:`${r} ${n} ${o}`}if("equal"!=e.op&&"notEqual"!=e.op){if("and"==e.op)return t.push(`if (!(${r})) {`),t.push("continue;"),t.push("}"),q(e.arg[1],t);throw new Error("pure operation not supported: "+S(e))}{let i=q(e.arg[1],t);if(o.isString(e.arg[0].schema.type)&&o.isString(e.arg[1].schema.type)){let{file:e,start:o,end:s}=r,{file:p,start:a,end:l}=i,u=g("tmp_cmpstr");return t.push(`int ${u} = compare_str1(${e}, ${o}, ${s}, ${p}, ${a}, ${l}) ${n} 0;`),u}if(o.isInteger(e.arg[0].schema.type)&&o.isInteger(e.arg[1].schema.type))return`${r} ${n} ${i}`}}},j=(e,t,r)=>{let{val:n}=u[r],i=g("pos");e.push(`unsigned long ${i} = ${r}_hash & 255;`);let s=`${t}_htable[${i}]`,{keySchema:p}=f[t];if(o.isString(p)){let r=`${t}_keys_str[${s}]`,o=`${t}_keys_len[${s}]`,p=`${n.file} + ${n.start}`,a=`${n.end} - ${n.start}`;e.push(`while (${s} != -1 && compare_str2(${r}, ${o}, ${p}, ${a}) != 0) {`),e.push(`${i} = (${i} + 1) & 255;`),e.push("}")}else e.push(`while (${s} != -1 && ${t}_keys[${s}] != ${n}) {`),e.push(`${i} = (${i} + 1) & 255;`),e.push("}");return s=g("key_pos"),e.push(`int ${s} = ${t}_htable[${i}];`),[i,s]},E=(e,t,r,n)=>{let[i,s]=j(e,t,r);e.push(`if (${s} == -1) {`),e.push(`${s} = ${t}_key_count;`),e.push(`${t}_key_count++;`),e.push(`${t}_htable[${i}] = ${s};`);let p,{val:a}=u[r],{keySchema:l,valSchema:m}=f[t];if(o.isString(l)){let r=`${t}_keys_str[${s}]`,n=`${t}_keys_len[${s}]`;e.push(`${r} = ${a.file} + ${a.start};`),e.push(`${n} = ${a.end} - ${a.start};`)}else e.push(`${t}_keys[${s}] = ${a};`);e.push("}"),p=o.isString(m)?{str:`${t}_values_str[${s}]`,len:`${t}_values_len[${s}]`}:`${t}_values[${s}]`,e.push(n(p))},P=(e,t,r,n)=>{if(e.push(`// init hashmap for ${t}`),e.push(`// keys of ${t}`),o.isString(r))e.push(`char **${t}_keys_str = (char **)malloc(256 * sizeof(char *));`),e.push(`int *${t}_keys_len = (int *)malloc(256 * sizeof(int));`);else{let n=v(r);e.push(`${n} *${t}_keys = (${n} *)malloc(256 * sizeof(${n}));`)}if(e.push(`// key count for ${t}`),e.push(`int ${t}_key_count = 0;`),e.push(`// hash table for ${t}`),e.push(`int *${t}_htable = (int *)malloc(256 * sizeof(int));`),e.push(`// init hash table entries to -1 for ${t}`),e.push(`for (int i = 0; i < 256; i++) ${t}_htable[i] = -1;`),e.push(`// values of ${t}`),o.isString(n))e.push(`char **${t}_values_str = (char **)malloc(256 * sizeof(char *));`),e.push(`int *${t}_values_len = (int *)malloc(256 * sizeof(int));`);else{let r=v(n);e.push(`${r} *${t}_values = (${r} *)malloc(256 * sizeof(${r}));`)}f[t]={keySchema:r,valSchema:n}},N=(e,t)=>{let r=[];if("stateful"==e.key)if(r.push(`// init ${t} for ${e.op}`),e.fre.length>0){let n;if("sum"==e.op||"count"==e.op)n="= 0";else if("product"==e.op)n="= 1";else if("min"==e.op)n="= INT_MAX";else{if("max"!=e.op)throw new Error("stateful op not supported: "+S(e));n="= INT_MIN"}((e,t,r,n)=>{let[i,s]=j(e,t,r);e.push(`if (${s} == -1) {`),e.push(`${s} = ${t}_key_count;`),e.push(`${t}_key_count++;`),e.push(`${t}_htable[${i}] = ${s};`);let p,{val:a}=u[r],{keySchema:l,valSchema:m}=f[t];if(o.isString(l)){let r=`${t}_keys_str[${s}]`,n=`${t}_keys_len[${s}]`;e.push(`${r} = ${a.file} + ${a.start};`),e.push(`${n} = ${a.end} - ${a.start};`)}else e.push(`${t}_keys[${s}] = ${a};`);p=o.isString(m)?{str:`${t}_values_str[${s}]`,len:`${t}_values_len[${s}]`}:`${t}_values[${s}]`,e.push(n(p)),e.push("}")})(r,t,e.fre[0],(e=>`${e} ${n};`))}else if("sum"==e.op||"count"==e.op)r.push(`${v(e.schema.type)} ${t} = 0;`);else if("product"==e.op)r.push(`${v(e.schema.type)} ${t} = 1;`);else if("min"==e.op)r.push(`${v(e.schema.type)} ${t} = INT_MAX;`);else{if("max"!=e.op)throw new Error("stateful op not supported: "+S(e));r.push(`${v(e.schema.type)} ${t} = INT_MIN;`)}else{if("update"!=e.key)throw new Error("unknown op: "+S(e));{r.push(`// init ${t} for group`);let{schema:n}=u[e.arg[1].op];P(r,t,n.type,e.schema.type.objValue)}}return r},O=(e,t)=>{let r=[];if("prefix"==e.key)throw new Error("prefix op not supported: "+S(e));if("stateful"==e.key){r.push(`// update ${t} for ${e.op}`);let[n]=e.arg.map((e=>q(e,r)));if("print"==e.op){if(o.isString(e.arg[0].schema.type)){let{file:e,start:t,end:o}=n;r.push(`println(${e}, ${t}, ${o});`)}else{let[t]=e.arg.map((e=>q(e,r)));r.push(`printf("%${b(e.arg[0].schema.type)}\\n", ${t});`)}return r}if(e.fre.length>0){let i;if("sum"==e.op)i=e=>`${e} += ${n};`;else if("product"==e.op)i=e=>`${e} += ${n};`;else if("min"==e.op)i=e=>`${e} = ${n} < ${e} ? ${n} : ${e};`;else if("max"==e.op)i=e=>`${e} = ${n} > ${e} ? ${n} : ${e};`;else if("count"==e.op)i=e=>`${e} += 1;`;else{if("single"!=e.op)throw new Error("stateful op not supported: "+S(e));i=o.isString(e.schema.type)?e=>`${e.str} = ${n.file} + ${n.start}; ${e.len} = ${n.end} - ${n.start};`:e=>`${e} = ${n};`}E(r,t,e.fre[0],i)}else if("sum"==e.op)r.push(`${t} += ${n};`);else if("product"==e.op)r.push(`${t} *= ${n};`);else if("min"==e.op)r.push(`${t} = ${n} < ${t} ? ${n} : ${t};`);else if("max"==e.op)r.push(`${t} = ${n} > ${t} ? ${n} : ${t};`);else{if("count"!=e.op)throw"single"==e.op?new Error("stateful op not implmeneted: "+S(e)):new Error("stateful op not supported: "+S(e));r.push(`${t} += 1;`)}}else{if("update"!=e.key)throw new Error("unknown op: "+S(e));{r.push(`// update ${t} for group`);let n,i=q(e.arg[2],r),{valSchema:s}=f[t];n=o.isString(s)?e=>`${e.str} = ${i.file} + ${i.start}; ${e.len} = ${i.end} - ${i.start};`:e=>`${e} = ${i};`,E(r,t,e.arg[1].op,n)}}return r},T=(e,t,r,n,i=!0)=>{if(null===n.objKey)return[];let s=[],p=e.arg[1].op,{mappedFile:u,size:f}=a[t],m=n.objKey,y=n.objValue,c=S(e),g=l[c][m];s.push(`// reading column ${m}`);let h=[u,d(p),m,"start"].join("_"),x=[u,d(p),m,"end"].join("_"),k=[u,d(p),m].join("_");g&&o.isInteger(y)&&s.push(`${v(y)} ${k} = 0;`);let b=i?"\\n":",";return s.push(`int ${h} = ${r};`),s.push(`while (${r} < ${f} && ${u}[${r}] != '${b}') {`),g&&o.isInteger(y)&&(s.push("// extract integer"),s.push(`${k} *= 10;`),s.push(`${k} += ${u}[${r}] - '0';`)),s.push(`${r}++;`),s.push("}"),s.push(`int ${x} = ${r};`),s.push(`${r}++;`),g&&o.isString(y)&&(s.push("// extract string"),s.push(`char ${k}[${x} - ${h} + 1];`),s.push(`extract_str(${u}, ${h}, ${x}, ${k});`)),[...T(e,t,r,n.objParent,!1),...s]},C=(e,t,r)=>()=>{let n=e.arg[1].op,{mappedFile:o,size:i}=a[t],s=[],p=[`// generator: ${n} <- ${S(e.arg[0])}`],l=g("i");s.push(`int ${l} = 0;`),s.push(`while (${l} < ${i} && ${o}[${l}] != '\\n') {`),s.push(`${l}++;`),s.push("}"),s.push(`${l}++;`);let u=[];u.push(`${d(n)} = -1;`),u.push("while (1) {"),u.push(`${d(n)}++;`);let f=[`if (${l} >= ${i}) break;`],m=e.schema.type,y=T(e,t,l,m);return{info:p,loadCSV:r,initCursor:s,loopHeader:u,boundsChecking:f,rowScanning:y}};t.generateCSqlNew=(e,t,g,x)=>{const k=r(840),v=r(994);let $=function(e){return new Promise((function(t,r){v.exec(e,(function(e,n){e&&r(e),t(n)}))}))},j=((e,t)=>{let r=[],g=[],x={};s=t.filters,p=t.assignments,vars=t.vars,order=t.ordeer,a={},c={},l={},u={},f={},w(e);let k=(e,...t)=>({txt:e,deps:t}),v=(e,t,n,o)=>{let i=k(e,...n,...o);i.lhs=k("LHS",...n),i.op="=?=",i.rhs=k("RHS",...o),i.writeSym=t,i.deps=i.deps.filter((e=>e!=i.writeSym)),x[i.writeSym]??=1,i.writeRank=x[i.writeSym],x[i.writeSym]+=1,r.push(i)},$=(e,t,r)=>{let n=E(e),o=E(t),i=k("FOR",...n);i.sym=o[0],i.getLoopTxt=r,g.push(i)},j=(e,t,r,n)=>{let i=E(e),s=E(t),p=k("MKSET",...i);p.sym=s[0];let a=[`// generator: ${t.op} <- ${S(e)}`],l=[];if(o.isString(n.type))l.push(`unsigned long ${p.sym}_hash = hash(${r.file}, ${r.start}, ${r.end});`);else{if(!o.isInteger(n.type))throw new Error("key type not supported: ",o.prettyPrintTuple(n));l.push(`unsigned long ${p.sym}_hash = (unsigned long)${r};`)}p.getLoopTxt=()=>({info:a,loadCSV:[],initCursor:[],loopHeader:["{","// singleton value here"],boundsChecking:[],rowScanning:l}),g.push(p)},E=e=>[...e.fre,...e.tmps.map(y)],T=[];T.push('#include "rhyme-sql.h"'),T.push("int main() {");let I={};for(let e in s){let t=s[e],r=t.arg[1].op,n=t.arg[0];if("loadInput"==n.key&&"csv"==n.op){let o,i=[];if("const"==n.arg[0].key&&"string"==typeof n.arg[0].op?(o=n.arg[0].op,null==a[o]&&_(T,o,e)):(o=q(n.arg[0],[],{},!0),null==a[o]&&_(i,o,e,!1)),!I[r]){let e=`${d(r)}`;T.push(`int ${e};`),I[r]=!0}let s=C(t,o,i);$(t.arg[0],t.arg[1],s)}else{if("mkset"!=n.key)throw new Error("invalid filter: "+S(t));{let e=q(n.arg[0],[]);u[r]={val:e,schema:n.arg[0].schema},j(t.arg[0],t.arg[1],e,n.arg[0].schema)}}}for(let e in p){let t=y(e),r=p[e];if("stateful"==r.key&&0!=r.fre.length){let{schema:e}=u[r.fre[0]],n=[];P(n,t,e.type,r.schema.type),v(n,t,[],[])}("stateful"==r.key&&h[r.op]||"update"==r.key)&&v(N(r,t),t,r.fre,[]);let n=[...m(r.fre,r.bnd),...r.tmps.map(y)];v(O(r,t,r.fre),t,r.fre,n)}let V=q(e,[],{}),A=[];return e.schema.type.typeSym!==i.never&&(f[V]?(A.push("// print hashmap"),((e,t)=>{let{keySchema:r,valSchema:n}=f[t];e.push("for (int i = 0; i < 256; i++) {"),e.push(`int keyPos = ${t}_htable[i];`),e.push("if (keyPos == -1) {"),e.push("continue;"),e.push("}"),e.push("// print key"),o.isString(r)?e.push(`print(${t}_keys_str[keyPos], ${t}_keys_len[keyPos]);`):e.push(`printf("%${b(r)}", ${t}_keys[keyPos]);`),e.push('print(": ", 2);'),e.push("// print value"),o.isString(n)?(e.push(`print(${t}_values_str[keyPos], ${t}_values_len[keyPos]);`),e.push('print("\\n", 1);')):e.push(`printf("%${b(n)}\\n", ${t}_values[keyPos]);`),e.push("}")})(A,V)):A.push(`printf("%${b(e.schema.type)}\\n", ${V});`)),A.push("return 0;"),A.push("}"),n({assignmentStms:r,generatorStms:g,tmpVarWriteRank:x,res:V,prolog:T,epilog:A},"c-sql")})(e,t),E=async e=>{let t=await(async()=>(await k.writeFile(`${g}/${x}`,j),await $(`gcc ${g}/${x} -o ${g}/tmp -Icgen-sql`),`${g}/tmp`))();return await $(t)};return E.explain={ir:t,code:j},E}},104:(e,t)=>{let r={},n={},o={},i={};t.typing=r,t.types=n,t.typeSyms=o,t.props=i;let s=(e,t)=>{return(r=[...e,...t]).filter(((e,t)=>r.indexOf(e)==t));var r},p=(e,t)=>{let r={},n=[];for(let e of t)r[e]=!0;for(let t of e)r[t]||n.push(t);return n},a=e=>{o[e]=e,n[e]={typeSym:e}};a("any"),a("never"),a("boolean"),a("string"),a("u8"),a("u16"),a("u32"),a("u64"),a("i8"),a("i16"),a("i32"),a("i64"),a("f32"),a("f64"),n.u8,n.u16,n.u32,n.u64,n.i8,n.i16,n.i32,n.i64,n.f32,n.f64,i.nothing="nothing",i.error="error";let l=[i.nothing];i.error,o.object="object",o.intersect="intersect",o.union="union",o.dynkey="dynkey",o.function="function",o.tagged_type="tagged_type",o.keyval="keyval",r.typeEquals=(e,t)=>!(!_(e,t)||!_(t,e));let u=(e,t)=>{if(!e.typeSym||!t.typeSym)return e==t;if(e.typeSym!=t.typeSym)return!1;switch(e.typeSym){case"union":return u(e.unionSet[0],t.unionSet[0])&&u(e.unionSet[1],t.unionSet[1]);case"intersect":return u(e.intersectSet[0],t.intersectSet[0])&&u(e.intersectSet[1],t.intersectSet[1]);case"dynkey":return e.keySymbol==t.keySymbol;case"tagged_type":return u(e.tagInnertype,t.tagInnertype)&&JSON.stringify(e.tagData)==JSON.stringify(t.tagData);case"object":return null===e.objKey?null===t.objKey:u(e.objKey,t.objKey)&&u(e.objValue,t.objValue)&&u(e.objParent,t.objParent);case"function":return e.funcParams.length==t.funcParams.length&&e.funcParams.reduce(((e,r,n)=>e&&u(r,t.funcParams[n])),u(e.funcResult,t.funcResult));default:return!0}};r.sameType=u;let f=e=>({type:e,props:[]}),m=e=>(e=h(e)).typeSym==o.union?m(e.unionSet[0])&&m(e.unionSet[1]):e.typeSym===o.object;r.isObject=m;let y=e=>(e=h(e),m(e)?e.typeSym==o.union?d(y(e.unionSet[0]),y(e.unionSet[1])):null===e.objKey?n.never:d(e.objKey,y(e.objParent)):n.never);r.getObjectKeys=y;let d=(e,t)=>_(e,t)?t:_(t,e)?e:{typeSym:o.union,unionSet:[e,t]};r.createUnion=d;let c=(e,t)=>_(e,t)?e:_(t,e)?t:q(e,t)?n.never:e.typeSym==o.union?d(c(e.unionSet[0],t),c(e.unionSet[1],t)):t.typeSym==o.union?d(c(e,t.unionSet[0]),c(e,t.unionSet[1])):{typeSym:o.intersect,intersectSet:[e,t]};r.createIntersection=c,r.createFunction=(e,...t)=>({typeSym:o.function,funcResult:e,funcParams:t});let g=(e,t="Key")=>"string"==typeof e?e:{typeSym:o.dynkey,keySymbol:R(t),keySupertype:e};r.createKey=g,r.keyval=(e,t)=>({typeSym:o.keyval,keyvalKey:e,keyvalValue:t});let h=e=>e.typeSym!=o.tagged_type?e:h(e.tagInnertype);r.removeTag=h;let x=(e,t,r)=>({typeSym:o.tagged_type,tag:e,tagData:t,tagInnertype:r});r.createTaggedType=x;let k=()=>{let e={typeSym:o.object,objKey:null,objValue:null,objParent:null},t={add:(r,n)=>(e={typeSym:o.object,objKey:r,objValue:n,objParent:e},t),build:()=>e};return t};r.objBuilder=k;let v=e=>{let t=k();for(let r of Object.keys(e))t.add(r,e[r]);return t.build()};r.createSimpleObject=v;let b=(e,t,r,n)=>0==r?n:x(e,{dim:r},k().add(g(t),b(e,t,r-1,n)).build());r.createVec=b,r.createVecs=(e,t,n,o)=>{let i=r.createKey(t);return 1==n?o.map((t=>r.createTaggedType(e,{dim:n},r.objBuilder().add(i,t).build()))):r.objBuilder().add(i,r.createVec(e,t,n-1,o)).build().map((t=>r.createTaggedType(e,{dim:n},t)))};let S=(e,t)=>{switch(e.type.typeSym){case o.tagged_type:return S({type:h(e.type),props:e.props},t);case o.union:let r=S({type:e.type.unionSet[0],props:e.props},t),i=S({type:e.type.unionSet[1],props:e.props},t);return{type:d(r.type,i.type),props:s(r.props,i.props)};case o.object:if(null===e.type.objValue)return{type:n.never,props:l};let p=e.type.objKey,a=e.type.objValue,u=e.type.objParent,m=s(e.props,t.props);if(_(t.type,p))return{type:a,props:m};let{type:y,props:c}=S(f(u),t);return m=s(m,c),q(p,t.type)?{type:y,props:m}:{type:d(a,y),props:m};case o.never:return{type:n.never,props:l};default:throw new Error("Unable to perform access on non-object type: "+C(e.type))}};r.performObjectGet=S;const $=[[n.u8,n.u16,n.u32,n.u64],[n.i8,n.i16,n.i32,n.i64],[n.u8,n.i16,n.i32,n.i64],[n.u16,n.i32,n.i64],[n.u32,n.i64],[n.i8,n.i16,n.f32,n.f64],[n.u8,n.u16,n.f32,n.f64],[n.u8,n.u16,n.i32,n.f64],[n.u32,n.f64]];let w=(e,t)=>{if(u(e,t))return!0;switch(e.typeSym){case o.union:{let r=w(e.unionSet[0],t),n=w(e.unionSet[1],t);return r&&n}case o.intersect:{let r=w(e.intersectSet[0],t),n=w(e.intersectSet[1],t);return r||n}default:switch(t.typeSym){case o.union:{let r=w(e,t.unionSet[0]),n=w(e,t.unionSet[1]);return r||n}case o.intersect:{let r=w(e,t.intersectSet[0]),n=w(e,t.intersectSet[1]);return r&&n}default:return((e,t)=>{if(u(e,t))return!0;if(e.typeSym==o.never)return!0;if(t.typeSym==o.any)return!0;if(e.typeSym==o.any)return!1;if(t.typeSym==o.never)return!1;if("string"==typeof e&&t.typeSym===o.string)return!0;if(e.typeSym===o.tagged_type&&(e=e.tagInnertype),t.typeSym===o.tagged_type&&(t=t.tagInnertype),t.typeSym===o.dynkey)return!1;if(e.typeSym===o.dynkey&&w(e.keySupertype,t))return!0;if(e.typeSym===o.function)return t.typeSym===o.function&&e.funcParams.length===t.funcParams.length&&!!w(e.funcResult,t.funcResult)&&!!e.funcParams.reduce(((r,n,o)=>r&&w(t.funcParams[o],e.funcParams[o])),!0);if(m(e)&&m(t)){if(null===t.objKey)return!0;if(null===e.objKey)return!1;let r=[],n=f(e);for(let e=t;null!=e.objKey;e=e.objParent){let t=e.objKey,{type:o,props:i}=S(n,f(t)),s=e.objValue;for(let e of r)q(t,e[0])||(s=d(s,e[1]));if(!_(o,s)||0!=i.length)return!1;r.push([e.objKey,e.objValue])}return!0}for(let r of $){let n=r.indexOf(e);if(-1===n)continue;let o=r.indexOf(t);if(-1!==o&&n<o)return!0}return!1})(e,t)}}},_=w;r.typeConforms=w,r.isSubtype=w;let q=(e,t)=>{switch(e.typeSym){case o.never:return!0;case o.any:return t.typeSyms==o.never;case o.union:{let r=q(e.unionSet[0],t),n=q(e.unionSet[1],t);return r&&n}}switch(t.typeSym){case o.never:return!0;case o.any:return!1;case o.union:{let r=q(t.unionSet[0],e),n=q(t.unionSet[1],e);return r&&n}}if(_(e,t)||_(t,e))return!1;let r="",n="";return E(e)&&(r="num"),E(t)&&(n="num"),T(e)&&(r="str"),T(t)&&(n="str"),P(e)&&(r="bool"),P(t)&&(n="bool"),""!=r&&""!=n&&r!=n||!(!T(e)||!T(t))&&e.typeSym!=o.dynkey&&t.typeSym!=o.dynkey};r.typeDoesntIntersect=q;let j=e=>(e=h(e)).typeSym===o.union?j(e.unionSet[0])&&j(e.unionSet[1]):e.typeSym===o.intersect?j(e.intersectSet[0]):e.typeSym===o.dynkey?j(e.keySupertype):e.typeSym===o.u8||e.typeSym===o.u16||e.typeSym===o.u32||e.typeSym===o.u64||e.typeSym===o.i8||e.typeSym===o.i16||e.typeSym===o.i32||e.typeSym===o.i64;r.isInteger=j;let E=e=>!!j(e)||((e=h(e)).typeSym===o.union?E(e.unionSet[0])&&E(e.unionSet[1]):e.typeSym===o.intersect?E(e.intersectSet[0]):e.typeSym===o.dynkey?E(e.keySupertype):e.typeSym===o.f32||e.typeSym===o.f64);r.isNumber=E;let P=e=>(e=h(e)).typeSym===o.union?P(e.unionSet[0])&&P(e.unionSet[1]):e.typeSym===o.intersect?P(e.intersectSet[0]):e.typeSym===o.dynkey?P(e.keySupertype):e.typeSym===o.boolean;r.isNumber=E;let N=e=>e.typeSym===o.tagged_type&&"sparse"===e.tag;r.isSparse=N,r.isSparseVec=e=>N(e)&&1==e.tagData.dim,r.isSparseMat=e=>N(e)&&2==e.tagData.dim,r.isDense=e=>e.typeSym===o.tagged_type&&"dense"===e.tag;let O=e=>{if(!E(e))throw new Error("Unable to generalize non-number value.");switch(e.typeSym){case o.union:return d(O(e.unionSet[0]),O(e.unionSet[1]));case o.intersect:return d(O(e.intersectSet[0]),O(e.intersectSet[1]));case o.dynkey:return O(e.keySupertype);case o.tagged_type:return O(e.tagInnertype);default:return e}},T=e=>e.typeSym===o.union?T(e.unionSet[0])&&T(e.unionSet[1]):(e=h(e)).typeSym===o.dynkey?T(e.keySupertype):e.typeSym===o.string||"string"==typeof e;r.isString=T;let C=e=>void 0===e?"~Undefined~":null===e?"~Null~":e.typeSym in n?e.typeSym:"string"==typeof e?'"'+e+'"':e.typeSym===o.union?"("+Array.from(e.unionSet).map((e=>C(e))).join(" | ")+")":e.typeSym===o.function?"("+e.funcParams.map((e=>C(e))).join(", ")+") -> "+C(e.funcResult):e.typeSym===o.dynkey?"<"+C(e.keySupertype)+">":e.typeSym===o.tagged_type?e.tag+":"+C(e.tagInnertype):m(e)?null===e.objKey?"{}":`${C(e.objParent)}{${C(e.objKey)}: ${C(e.objValue)}}`:"object"==typeof e?"~UNK:"+JSON.stringify(e)+"~":"~Invalid~";r.prettyPrintType=C,r.prettyPrintTuple=e=>{if(void 0===e)return"~Undefined~";let t="";return t=e.props.includes(i.nothing)?e.props.includes(i.error)?"N,E":"N":e.props.includes(i.error)?"E":"/",C(e.type)+" | "+t};let I=e=>e.split("\n").join("\n  "),V=e=>{if(void 0===e)throw new Error("Undefined query.");if("input"===e.key)return"inp";if("const"===e.key)return"object"==typeof e.op?"{}":String(e.op);if("var"===e.key)return e.op;if("get"===e.key){let[t,r]=e.arg.map(V);return`${t}[${r}]`}if("pure"===e.key){let t=e.arg.map(V);return e.op+"("+t.join(", ")+")"}if("hint"===e.key)return n.never;if("mkset"===e.key){let[t]=e.arg.map(V);return`mkset(${t})`}if("prefix"===e.key){let[t]=e.arg.map(V);return"prefix_"+e.op+"("+t+")"}if("stateful"===e.key){let[t]=e.arg.map(V);return e.op+"("+t+")"}if("group"===e.key){let[t,r]=e.arg.map(V);return"{ "+t+": "+r+" }"}if("update"===e.key){let[t,r,n,o]=e.arg.map(V);return o?`${t} {\n    ${r}: ${I(n)}\n  } / ${o} `:`(${t} {\n    ${r}: ${I(n)}\n})`}throw new Error("Unable to determine type of query: "+e.key+" "+JSON.stringify(e))},A=0,R=e=>e+A++,L=(e,t,r,n,o)=>{let i=F(e,t,r,n,o);return o.schema=i,i},F=(e,t,r,a,c)=>{let h=n=>L(e,t,r,a,n);if(void 0===c)throw new Error("Undefined query.");if("input"===c.key)return f(e);if("loadInput"===c.key){let e=c.arg.map(h),t=e[0].type;if(!T(t))throw new Error("Filename in loadInput expected to be a string but got "+C(t));return{type:c.schema,props:e[0].props}}if("const"===c.key){if("object"==typeof c.op&&0===Object.keys(c.op).length)return f(v({}));if("number"==typeof c.op)return c.op<0?c.op>=-127?f(n.i8):c.op>=-32767?f(n.i16):c.op>=-2147483647?f(n.i32):f(n.i64):c.op<256?f(n.u8):c.op<=65535?f(n.u16):c.op<=4294967295?f(n.u32):f(n.u64);if("string"==typeof c.op)return f(c.op);throw new Error("Unknown const: "+c.op)}if("var"===c.key){if(void 0===r[c.op])throw new Error("Unable to determine type of variable, given no context.");return r[c.op]}if("get"===c.key){let e=h(c.arg[0]),t=e.type;if(!m(t))throw new Error("Unable to perform get operation on non-object: "+C(t));let n=c.arg[1];if("var"==n.key&&!r[n.op]){let e=y(t);r[n.op]={type:e,props:[]}}let o=h(c.arg[1]);return S(e,o)}if("pure"===c.key){let e=c.arg.map(h),{type:t,props:r}=e[0];if("apply"==c.op){if(t.typeSym!=o.function)throw new Error(`Unable to apply a value to a non-function value (type ${C(t)})`);if(t.funcParams.length+1!=e.length)throw new Error("Unable to apply function. Number of args do not align.");let r=[];for(let n=0;n<e.length-1;n++){let{type:o,props:i}=e[n+1],p=t.funcParams[n];if(!_(o,p))throw new Error(`Unable to apply function. Argument ${n+1} does not align.\nExpected: ${C(p)}\nReceived: ${C(o)}.`);r=s(r,i)}return{type:t.funcResult,props:r}}if("equal"===c.op||"and"===c.op||"notEqual"===c.op||"fdiv"===c.op||"plus"===c.op||"minus"===c.op||"times"===c.op||"div"===c.op||"mod"===c.op){let{type:o,props:i}=e[1];if("plus"==c.op||"minus"==c.op||"times"==c.op||"div"==c.op||"mod"==c.op){if(!E(t)||!E(o))throw new Error(`Unable to perform ${c.op} on values of type ${C(t)} and ${C(o)}`);return{type:O(d(t,o)),props:s(r,i)}}if("fdiv"==c.op)return{type:n.f64,props:s(r,i)};if("equal"==c.op)return{type:n.boolean,props:s(r,i)};if("notEqual"==c.op)return{type:n.boolean,props:s(r,i)};if("and"==c.op)return{type:o,props:i};throw new Error("Pure operation not implemented: "+c.op)}throw new Error("Pure operation not implemented: "+c.op)}if("hint"===c.key)return{type:n.never,props:[]};if("mkset"===c.key){let e=c.arg.map(h),t=e[0].type,r=g(t,"Mkset");return e[0].props.includes(i.nothing)||a.push(r),{type:k().add(r,n.boolean).build(),props:p(e[0].props,l)}}if("prefix"===c.key)throw new Error("Unimplemented");if("stateful"===c.key){let e=c.arg.map(h)[0],t=e.type;if(u(t,n.never))throw new Error("Unable to evaluate stateful expression on never type.");if("sum"===c.op||"product"===c.op){if(!E(t))throw new Error(`Unable to ${c.op} non-number values currently. Got: ${C(t)}`);return{type:t,props:p(e.props,l)}}if("min"===c.op||"max"===c.op){if(!E(t))throw new Error("Unable to union non-number values currently.");return{type:t,props:e.props}}if("count"===c.op)return{type:n.u32,props:p(e.props,l)};if("single"===c.op||"first"===c.op||"last"===c.op)return e;if("array"===c.op){let r=g(n.u32,"Array");return e.props.includes(i.nothing)||a.push(r),{type:k().add(r,t).build(),props:p(e.props,l)}}if("print"===c.op)return{type:n.never,props:[]};throw new Error("Unimplemented stateful expression "+c.op)}if("group"===c.key)throw new Error("Unimplemented");if("update"===c.key){c.arg[3]&&h(c.arg[3]);let e=h(c.arg[0]),t=h(c.arg[2]),r=h(c.arg[1]),{type:n,props:i}=e;if(!m(n))throw new Error("Unable to update field of type: "+C(n));if("vars"===c.arg[1].op)throw new Error("Unimplemented");let{type:u,props:f}=r,{type:y,props:d}=t;if(!j(u)&&!T(u))throw new Error("Unable to use type: "+C(u)+" as object key");let x=s(f,d),k=g(u,"update");return x.includes(x.nothing)||a.push(k),{type:{typeSym:o.object,objKey:k,objValue:y,objParent:n},props:s(p(x,l),i)}}throw new Error("Unable to determine type of query: "+V(c))};r.parseType=e=>{if(void 0!==e){if("string"==typeof e)return e;if("object"!=typeof e)throw new Error("Unknown type: "+e);switch(e.typeSym){case void 0:if(0==Object.keys(e).length)return r.createSimpleObject({});let t=Object.keys(e)[Object.keys(e).length-1],n=r.parseType(e[t]),{[t]:i,...s}=e;n.typeSym==o.keyval&&(t=r.parseType(n.keyvalKey),n=r.parseType(n.keyvalValue));let p=r.parseType(s);return{typeSym:o.object,objKey:t,objValue:n,objParent:p};case o.union:return e.unionSet[0]=r.parseType(e.unionSet[0]),e.unionSet[1]=r.parseType(e.unionSet[1]),e;case o.intersect:return e.intersectSet[0]=r.parseType(e.intersectSet[0]),e.intersectSet[1]=r.parseType(e.intersectSet[1]),e;case o.dynkey:return e.keySupertype=r.parseType(e.keySupertype),e;case o.function:return e.funcParams=e.funcParams.map(r.parseType),e.funcResult=r.parseType(e.funcResult),e;case o.object:return null===e.objKey||(e.objKey=r.parseType(e.objKey),e.objValue=r.parseType(e.objValue),e.objParent=r.parseType(e.objParent)),e;case o.tagged_type:case o.tagged_type:return e.tagInnertype=r.parseType(e.tagInnertype),e;default:return e}}},r.validateIR=(e,t)=>{if(void 0!==e)return e=r.parseType(e),L(e,{},{},[],t)}},798:function(e,t){t.quoteVar=e=>e.replaceAll("*","x"),t.debug=!1,t.trace=!1,t.print=(...e)=>{this.debug&&console.log(...e)},t.inspect=(...e)=>{this.debug&&console.dir(...e)},t.error=(...e)=>{console.error(...e)},t.warn=(...e)=>{console.warn(...e)}}},__webpack_module_cache__={};function __webpack_require__(e){var t=__webpack_module_cache__[e];if(void 0!==t)return t.exports;var r=__webpack_module_cache__[e]={exports:{}};return __webpack_modules__[e].call(r.exports,r,r.exports,__webpack_require__),r.exports}var __webpack_exports__=__webpack_require__(32);return __webpack_exports__})()));
